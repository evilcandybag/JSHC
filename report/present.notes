Titel:	P
  - Upplägg för presentationen. 
  	% börjar med att presentera projektet, vad vi gjort
    % mitten en kort genomgång över programstruktur
    % slutar med en diskussion om projektet och dess framtid

Vad är det?: P 
  - Säg vad som står i sliden.
  	% vårt projekt har gått ut på att skriva en kompilator som kompilerar Haskell till JS.
  	  Skriven i JS.
  	
Varför JavaScript?: P 
  - Fråga vad folk har för koll på skriptning på klientsidan
  		IF bra THEN skippa grafen ELSE visa den
  	% skriptning på klientsidan gör det billigare och lättare att sätta upp en server med
  	  komplicerad applikation på
  	% alternativ: insticksmoduler till webläsaren; kräver mer av användaren är JS
  
Vad är JavaScript?: P 
  - Snabb genomgång av vad JS är för språk
  	% imperativt: liknar Java syntaxmässgit
  	% objektorienterat: använder sig av prototyper ist för klasser
  	% dynamiskt typat: variabler har ingen speciell typ, typer kontrolleras runtime
  	% första klassens funktioner: innebär att funktioner kan skapas och skickas runt som 
  	  vilka andra värden som helst
  	
Varför är det vettigt att översätta JS?:

Exempel på JavaScript: P 
  - Presentera exemplet, det finns två stora problem här.
  
  - Vi har hämtat någon annans kod; hur vet vi att den gör det den ska?
  		% Utan typkontroll måste kod som ska garantera ngt komma med en testsvit så
  		  användaren kan testa. men är testsviten bra?
  		
  - Klipp och klistra är ett dåligt sätt att flytta kod. många felkällor. 
  	% alla vet ju att copy-paste-programmering är dåligt. avsaknaden av modulsystem 
  	  leder till skapande av icke-modulär kod  

En lösning: Bibliotek: S
 
En lösning: översätt! S

Varför just Haskell?: S

Möjligheter att använda Haskell för webbprogrammering finns redan: S

DEMO:

ones = 1 : ones

fac 0 = 1
fac n = n * fac (n-1)

threeSixes = map (\ x -> 5 + x) $ take 3 ones 


PRODUKTEN:
Kompilering: en översikt: P

  - Abstrakt representation
    % skapa en abstrakt representation av koden. datastruktur som kompilatorn kan använda 
      sig av. Ofta ett träd. 
  
  - Kontroll av representation
    % Gå igenom representationen. Kolla efter fel, vanliga exempel; 
      namnkontroll: kolla att alla namn som används finns, och att det inte finns namnkonflikter
      typkontroll: kolla att värden av rätt typ används på rätt ställe
    
  - Generering av målrepresentation
	% Översätta representationen till någon konkret representation, t.ex. maskinkod, bytekod
	  någon assembly eller ett annat högnivåspråk 

Hur fungerar JSHC?: S


DISKUSSION:
Problem vi stött på under arbetet: P
  -projektets storlek
  		% vi underskattade haskells omfattning, och vilken svår uppgift det skulle vara 
  		  att implementera. Ursprungsplanen var att implementera stöd för hela språket,
  		  vi har endast lyckats få med en delmängd
  		% Dynamisk typning i JS gjorde att debugging tog mycket lång tid när projektet 
  		  växte. en stor del av felen vi hade uppfattades som sådant som kunnat undvikas
  		  med statisk typkontroll. 
  		  
  - Rekursiva moduler
  	% Avsaknaden av literatur i ämnet (många haskellimplementationer undviker problemet
  	  istället för att lösa det, GHC t.ex. klarar inte det) gjorde att vi försökte lösa 
  	  problemet själva. Först mot slutet av arbetet stötte vi på litteratur som beskriver
  	  en lösning på problemet. 

I framtiden: P

  - Typklasser P 
  		% Detta är hur överlagring fungerar i Haskell, för att kunna skriva vettiga program
  		  är typklasser nödvändiga
  		  
  - FFI
  		% För att kunna skapa program som är meningsfulla i en webkontext behövs FFI mot 
  		  JS. 
  		  
  - Rekursiva moduler 
  		% Haskellspecifikationen kräver rekursiva moduler, detta fungerar inte ännu.
  
  - Vår kompilator stöder ännu bara en liten del av haskellsyntaxen. 
  		% Det finns ett antal luckor i syntaxen som kräver ganska lite arbete för att lägga till
  				
  - Standardbibliotek
  		% De standardbibliotek vi implementerat är bara en bråkdel av alla som finns
  		  i specifikationen. 
