Titel:	P
  - Jag heter peter och det här är staffan, vi är här för att presentera vårt projekt,
    JSHC, som står för JavaScript Haskell Compiler
    
  - Upplägg för presentationen. 
  	% börjar med att presentera motivationen till projektet
  	% demonstrerar projektet
    % översiktlig genomgång av projektets struktur 
    % slutar med en diskussion om fallgropar i projektet och dess framtid

Vad är det?: P 
  - Säg vad som står i sliden.
  	% vårt projekt har gått ut på att skriva en kompilator som kompilerar Haskell till JS.
  	  Skriven i JS.
  	
Varför JavaScript?: P 
  	% skriptning på klientsidan gör det billigare och lättare att sätta upp en server med
  	  komplicerad applikation på
  	% Eftersom JS är de facto standard för skriptning på klientsidan idag, stöds av alla 
  	  större browsers,
  	  så kan man köra den kompilerade koden på klientsidan
  	  och även generera koden på klientsidan
  	  Kompilatorn kan köras på vilken plattform som helst som har en webbläsare  
  	   
Vad är JavaScript?: P 
  - Snabb genomgång av vad JS är för språk
  	% imperativt: liknar Java syntaxmässgit
  	% objektorienterat: använder sig av prototyper ist för klasser
  	% dynamiskt typat: variabler har ingen speciell typ, typer kontrolleras runtime
  	% första klassens funktioner: innebär att funktioner kan skapas och skickas runt som 
  	  vilka andra värden som helst

Exempel på JavaScript: P 
  - Presentera exemplet, kod för autocomplete i ett textfält.
    inget konstigt med sådan här kod. det finns dock två stora problem här.
  
  - Vi har hämtat någon annans kod; hur vet vi att den gör det den ska?
  		% Utan typkontroll finns ingen som helst formell garanti att koden gör något i
  		  närheten av vad den ska. enda sättet att ta reda på det är att testköra.
  		
  - Klipp och klistra är ett dåligt sätt att flytta kod. många felkällor. 
  	% alla vet ju att copy-paste-programmering är dåligt. avsaknaden av modulsystem 
  	  leder till skapande av icke-modulär kod, exempel; en javaprogrammerare laddar upp
  	  sin klass med dokumentation om interface

En lösning: Bibliotek: S
 
En lösning: översätt! S

Varför just Haskell?: S

Möjligheter att använda Haskell för webbprogrammering finns redan: S

DEMO:

PRODUKTEN:
Kompilering: en översikt: P
  % Det finns ett oändligt antal sätt att lösa kompilering på, och det är svårt att täcka
    ämnet generellt, men vi har delat upp processen i tre steg som förekommer i de flesta
    kompilatorer vi kommit i kontakt med. 

  - Abstrakt representation
    % skapa en abstrakt representation av koden. datastruktur som kompilatorn kan använda 
      sig av. Ofta ett träd, abstrakt syntaxträd  
  
  - Kontroll av representation
    % Gå igenom representationen. Kolla efter fel, vanliga exempel; 
      namnkontroll: kolla att alla namn som används finns, och att det inte finns namnkonflikter
      typkontroll: kolla att värden av rätt typ används på rätt ställe
    
  - Generering av målrepresentation
	% Översätta representationen till någon konkret representation, t.ex. maskinkod, bytekod
	  någon assembly eller ett annat högnivåspråk 

Hur fungerar JSHC?: S


DISKUSSION:
Problem vi stött på under arbetet: P
  -projektets storlek
  		% vi underskattade haskells omfattning, och vilken svår uppgift det skulle vara 
  		  att implementera. Ursprungsplanen var att implementera stöd för hela språket,
  		  vi har endast lyckats få med en delmängd
  		% Dynamisk typning i JS gjorde att debugging tog mycket lång tid när projektet 
  		  växte. en stor del av felen vi hade uppfattades som sådant som kunnat undvikas
  		  med statisk typkontroll. 
  		  
  - Rekursiva moduler
  	% Avsaknaden av literatur i ämnet (många haskellimplementationer undviker problemet
  	  istället för att lösa det, GHC t.ex. klarar inte det) gjorde att vi försökte lösa 
  	  problemet själva. Först mot slutet av arbetet stötte vi på litteratur som beskriver
  	  en lösning på problemet. 

I framtiden: P

  - Typklasser P 
  		% Detta är hur överlagring fungerar i Haskell, för att kunna skriva vettiga program
  		  är typklasser nödvändiga. Just nu har vi t.ex. enbart 32bitars heltal,
  		  för att kunna använda fler numeriska typer behövs överlagring
  		  
  - FFI
  		% FFI är Haskells sätt att importera och anropa funktioner från andra språk.
  		  Just nu kan vår genererade kod anropas av JS, men inte själv komma åt JS-kod.
  		  För att t.ex. komma åt DOM-objekt behövs ett FFI till JS.
  		  
  - Rekursiva moduler 
  		% Haskellspecifikationen kräver rekursiva moduler, dettMaybe Maybe      [[]]a fungerar inte ännu.
  
  - Vår kompilator stöder ännu bara en liten del av haskellsyntaxen. 
  		% Det finns ett antal luckor i syntaxen som kräver ganska lite arbete för att lägga till
  				
  - Standardbibliotek
  		% De standardbibliotek vi implementerat är bara en bråkdel av alla som finns
  		  i specifikationen. 
