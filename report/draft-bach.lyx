#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
\myTOC
\clearpage
\pagenumbering{arabic}
}
\end_preamble
\use_default_options true
\begin_modules
logicalmkup
\end_modules
\language english
\inputencoding utf8-plain
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Modern web applications are becoming more and more complex, with users expecting
 more and more automation of menial tasks such as spelling correction and
 autocompletion of text.
 This leads to web applications becoming larger and more complex, which
 in turn means that they are becoming more error prone<TODO: reference?>.
 One large source of errors in web applications is the absence of type safety
 in the form of static type checking in most scripting languages aimed at
 web development, such as JavaScript or PHP 
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js,type-system-dyn-web"

\end_inset

.
 One solution to this problem is providing an extra layer of abstraction
 on top of these scripts, that in turn can be subject to static type checking.
 For example another, already existing, programming language that has these
 features can be used 
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js,HTML-in-haskell,CGI-haskell"

\end_inset

.
 
\end_layout

\begin_layout Standard
Haskell is one such language, designed with type-safety as one of the major
 concerns <TODO:ref: ?>.
 By compiling Haskell directly to JavaScript, we use its strong type system
 to guard against some of the errors that are hard to avoid when writing
 large and complex application with a dynamically typed language such as
 JavaScript.
 <TODO: better formulation plox> 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Using Haskell for type safe web-programming is not a new concept.
 Several different approaches have been suggested; the use of Haskell to
 model HTML
\begin_inset CommandInset citation
LatexCommand cite
key "HTML-in-haskell"

\end_inset

 and using server-side Haskell applications to generate CGI
\begin_inset CommandInset citation
LatexCommand cite
key "CGI-haskell"

\end_inset

 are two examples.
 Other languages similar to Haskell have also been suggested for type safe
 web-applications, such as the functional logic language Curry
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js"

\end_inset

.
 <TODO: stuffe here> there are several projects out there with a similar
 approach to the one presented here.
 Notable ones are Yesod 
\begin_inset CommandInset citation
LatexCommand cite
key "yesod-book"

\end_inset

, which is a full-featured web server framework, and YCR2JS 
\begin_inset CommandInset citation
LatexCommand cite
key "yhc-js"

\end_inset

, a JavaScript back end to the York Haskell Compiler.
 <TODO: elaborate here>
\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
The purpose of this thesis is to present an implementation of a fully JavaScript
 Haskell-compiler (i.e.
 a compiler written entirely in JavaScript, compiling Haskell to JavaScript).
 Coupled with the compiler will be an interface in the form of a JavaScript-base
d text editor with an interactive code console (in the vein of the Glasgow
 Haskell Compiler's GHCi).
 By writing the compiler entirely in JavaScript, all computations will be
 performed by the client, thus greatly lightening the server load compared
 to having the computations run server-side, while still saving the user
 the work of downloading a compiler to their computer.
 The compiler supports the a subset of Haskell, as described in .
 <TODO; rewrite as much of this is filthy LIES!>
\end_layout

\begin_layout Chapter
Introduction to Haskell
\end_layout

\begin_layout Standard
This chapter is intended as a quick but thorough introduction to Haskell
 for readers unfamiliar with or new to Haskell and/or functional languages.
 It consists of a very general overview, followed by separate sub chapters
 with details about specific features.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Haskell is a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
lazy
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
purely functional
\end_layout

\end_inset

 programming language with 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
strong static typing
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
type inference
\end_layout

\end_inset

.
 A program in Haskell consists of one or more modules, interconnected by
 their import and export specifications.
 The contents of a module is a set of top-level declarations, which can
 be, among others, function declarations, datatype declarations and typeclass
 declarations.
 Functions consist of a name, a set of arguments and an expression, that
 expresses the result of the function when applied to its arguments.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being lazy means that an expression is only evaluated when its result is
 needed.
 Any expression whose result is not used is simply ignored.
 This enables lazy languages to feature some things that are otherwise impossibl
e, such as infinite data structures.
 Since the data structure is lazy, only the part that is needed.
 For example, a list of infinite length can be described in Haskell using
 like so:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x = [1..]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This statement assigns to the variable x an expression that calculates an
 infinite list containing all integers > 0 in rising order.
 While an expression calculating this in a strict language would never terminate
 as the set of integers > 0 is infinite, a lazy language only calculates
 the needed parts, e.g:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
take 5 x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where take is a function that returns a list consisting of the first n elements
 in a list, only needs the first 5 elements of x, so no more than 5 elements
 are computed.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being purely functional, Haskell's functions do not have side effects.
 <TODO: more on purity>
\end_layout

\begin_layout Standard
Another feature of purely functional languages is that functions are first-class
 objects.
 This means that functions can be passed around as arguments to other functions,
 be returned as the result of a function or created at runtime.
 This enables the creation of 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
higher order functions
\end_layout

\end_inset

, generalized functions that use other functions as arguments.
 For example, the function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
filter
\end_layout

\end_inset

 from the Haskell standard libraries takes a function, which takes one argument
 and returns a boolean, and a list.
 The function then applies the supplied function to each element in the
 list and returns a new list with all elements for which the supplied function
 returned 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Module system
\end_layout

\begin_layout Standard
Haskell’s module system is its main method of encapsulation.
 Apart from local variables in a certain function, it is the only way to
 determine whether something is known (i.e.
 in scope) or not.
 Each module has a name, a set of imports and a set of exports.
 The specification of these is optional, with defaults being “Main”, the
 empty import set and the export set containing all top-level declarations,
 respectively.
 
\end_layout

\begin_layout Standard
By specifying exports, nothing defined in the module that is not in the
 export space can be accessed by an importing module.
 It is also allowed to specify the export of imported modules or their respectiv
e exports.
 This way, if module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

 imports module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

 and module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C
\end_layout

\end_inset

 imports module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

, it is possible for module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C
\end_layout

\end_inset

 to also have imported some defnintions defined in module 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

 (or even module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

's entire export set), depending on what module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

's export set is.
\end_layout

\begin_layout Standard
It is also possible for a module to specify what it will import from another
 module, either as an inclusive specification or as an exclusive specification
 (using the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hiding
\end_layout

\end_inset

 keyword).
\end_layout

\begin_layout Standard
One important feature of Haskell's module system is that unlike, for example,
 Java, it is permitted for a group of modules to import each other.
 
\end_layout

\begin_layout Section
Dependency groups
\end_layout

\begin_layout Standard
Since modules can mutually depend on each other, there can be a cycle in
 the dependencies between modules.
\end_layout

\begin_layout Standard
If a module A and a module B depends on each other by importing functions
 from the other module, one can not analyse one before the other, as the
 imported functions will be missing.
\end_layout

\begin_layout Standard
To solve this, one must analyse A and B together.
\end_layout

\begin_layout Standard
More generally, one creates a dependency group for any set of modules that
 creates a dependency cycle such as A depends on B, B depends on C, and
 C depends on A.
\end_layout

\begin_layout Standard
The dependency groups are the strongly connected components in the directed
 graph of dependencies between single modules.
\end_layout

\begin_layout Standard
After they have been computed, the resulting graph is a DAG (directed acyclic
 graph) where nodes are dependency groups, and the edges are the dependencies
 between the groups.
\end_layout

\begin_layout Standard
As there are no cycles in the dependencies between the groups, it is possible
 to traverse the groups in dependency order (a reverse topological ordering).
\end_layout

\begin_layout Standard
The Haskell standard 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 mentions dependency groups in Chapters 4.5.1, 4.5.2, and 4.6, related to different
 topics.
\end_layout

\begin_layout Standard
This concept is used in two places of the compiler.
 It is needed to describe sets of modules that depend on each other, sets
 of top-level declarations that depend on each other (even between different
 modules), and declarations in let/where expressions.
\end_layout

\begin_layout Standard
The concept of dependency groups also applies to local definitions, for
 example, in the function:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f x = let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

even n = n `rem` 2 == 0
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in odd x
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where odd = not .
 even
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
there is a cyclic dependency between the declaration of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
even
\end_layout

\end_inset

 in the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 expression and the declaration of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
odd
\end_layout

\end_inset

 in the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expression.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename Dependency groups.png
	lyxscale 15
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
<TODO: smart and super cool text about dependency groups>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard
All values in haskell have a type.
\end_layout

\begin_layout Standard
The type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int -> Int
\end_layout

\end_inset

 represents a function which takes a value of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 and produces a result of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To be able to write a function that takes values that may be of more than
 one type, one uses 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type variables
\end_layout

\end_inset

, which are written with lower-case letters.
\end_layout

\begin_layout Standard
A function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
id :: a -> a
\end_layout

\end_inset

 (where
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
::
\end_layout

\end_inset

is read as 
\begin_inset Quotes eld
\end_inset

has type
\begin_inset Quotes erd
\end_inset

) is therefore a function that takes a value of any type and produces a
 result of the same type.
\end_layout

\begin_layout Standard
This is called a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
polymorphic type
\end_layout

\end_inset

, as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 can have a different type depending on how it is used, as the type variable
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

 can be replaced with different types.
\end_layout

\begin_layout Standard
Types can have 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type parameters
\end_layout

\end_inset

, which is necessary for collections if one wants to be able to use them
 where all values have the same type, but be able to choose that type.
\end_layout

\begin_layout Standard
A list of integers is written 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[Int]
\end_layout

\end_inset

, and a function that computes the length of a list as an 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 would have type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[a] -> Int
\end_layout

\end_inset

 as it would work regardless of the type of the values in the list.
 Note however that all the values must have the same type.
\end_layout

\begin_layout Standard
The list type is built-in.
 More generally, a type can be applied to any number of types as in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Array Int Double
\end_layout

\end_inset

 , which is an Array with indices of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 and stores values of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Quantification of types
\end_layout

\begin_layout Standard
Type variables, just as ordinary variables must be declared and used variables
 must be in scope of a declaration.
\end_layout

\begin_layout Standard
The declaration of variables is called 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
quantification
\end_layout

\end_inset

.
 A variable that is not declared is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
free
\end_layout

\end_inset

, and a variable that is declared is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
bound
\end_layout

\end_inset

 (by the quantification).
\end_layout

\begin_layout Standard
When writing a type signature in haskell, the quantification is implicit.
\end_layout

\begin_layout Standard
This means that a type signature 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[a] -> [a]
\end_layout

\end_inset

 is actually 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
∀a.
 [a] -> [a]
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
∀
\end_layout

\end_inset

 binds the type variable 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The implicit quantification of type signatures binds all type variables
 in the signature.
\end_layout

\begin_layout Standard
All type signatures written in a program and inferred by the compiler are
 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
rank-1 polymorphic types
\end_layout

\end_inset

, which means that the type given to a value begins with a quantification
 of all the type variables that occur in it, followed by the rest of the
 type which does not contain any quantifications.
 This makes the type system simpler.
\end_layout

\begin_layout Subsection
Type declarations
\end_layout

\begin_layout Standard
New types can be created.
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
data Tree a = Leaf | Node a (Tree a) (Tree a)
\end_layout

\end_inset

 declares a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type constructor
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 which can be applied to any type that one wants the values in the tree
 to have.
 It also declares the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
data constructor
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Leaf
\end_layout

\end_inset

 which represents an empty tree, and the data constructor 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Node
\end_layout

\end_inset

 which is used to construct a new tree given a value to store in the root
 node of the tree, and the left and right sub-tree.
\end_layout

\begin_layout Standard
The built-in lists have the special type constructor 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

, and the data constructors 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: ∀a.
 [a]
\end_layout

\end_inset

 (the empty list) and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:) :: ∀a.
 a -> [a] -> [a]
\end_layout

\end_inset

 (creating a new list given a first element and the rest of the elements).
\end_layout

\begin_layout Subsection
Kinds
\end_layout

\begin_layout Standard
The function type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree -> Tree
\end_layout

\end_inset

 is invalid as the type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 has a type parameter.
\end_layout

\begin_layout Standard
To detect these errors, all types and type constructors have a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
kind
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The kind of all types is 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A function type is valid if both the argument and result type have kind
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The kind of the type constructors 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 is 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
* -> *
\end_layout

\end_inset

, which means that they take a type and produce a type.
 They must therefore be applied to a type which is not missing any arguments
 (i.e have kind 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

), and will result in a type of kind 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Instantiation of types
\end_layout

\begin_layout Standard
When using a data constructor such as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: ∀a.[a]
\end_layout

\end_inset

, one would want to use it with lists with different element types in different
 locations.
\end_layout

\begin_layout Standard
This is achieved by replacing all bound type variables in the type with
 new type variables wherever it is used.
\end_layout

\begin_layout Standard
These type variables are now free, but will be bound after the type of the
 expression has been inferred unless they are eliminated by the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Type inference
\end_layout

\begin_layout Standard
If one makes a declaration 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
y = x : []
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset

, one will have:
\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:) :: "a -> [a] -> [a]"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: [b]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
b
\end_layout

\end_inset

 are free type variables.
\end_layout

\begin_layout Standard
To replace the type variables with types, one uses type inference which
 creates type constraint based upon how
\end_layout

\begin_layout Standard
the types are used.
\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x
\end_layout

\end_inset

 is the 1st argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = Int
\end_layout

\end_inset

 is created.
\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 is the 2nd argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[b] = [a]
\end_layout

\end_inset

 is created, which gives the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = b
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type inference algorithm must assign a single type to each of the free
 type variables such that all the constraints are satisified.
\end_layout

\begin_layout Standard
If there is more than one possible assignment, then the type is called ambiguous
, and is an error, unless a default
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report4.3.4"

\end_inset

 type can be chosen.
\end_layout

\begin_layout Standard
If there is no possible assignment, then an error will arise from the constraint
s.
\end_layout

\begin_layout Standard
In this case, there is only a single possible assignment, and the inferred
 types are:
\end_layout

\begin_layout Itemize
(:) :: Int -> [Int] -> [Int]
\end_layout

\begin_layout Itemize
[] :: [Int]
\end_layout

\begin_layout Itemize
y :: [Int]
\end_layout

\begin_layout Standard
<TODO: Example using function application and abstraction ?>
\end_layout

\begin_layout Chapter
Introduction to Compilation
\end_layout

\begin_layout Standard
This chapter is intended as an introduction to the general concepts of compilati
on for readers who have little or no experience with the inner workings
 of compilers.
 The approach to compilation described here is not the only one, and only
 describes the compilation steps used in JSHC.
 For a more general and in-depth view of compilers and compilation, 
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

 is recommended.
 
\end_layout

\begin_layout Standard
A compiler is a program that, given program code, produces new code in another
 language, the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
target language
\end_layout

\end_inset

.
 Common examples of compilers' target languages are machine code in the
 case of the GNU C Compiler <TODO: ref>, bytecode to be run in a virtual
 machine in the case of Java <TODO: ref> or another high level programming
 language in the case of the Glasgow Haskell Compiler, which compiles to
 C <TODO: ref>.
 
\end_layout

\begin_layout Standard
A compiler consists of two main parts; the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
front-end
\end_layout

\end_inset

 and the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
back-end
\end_layout

\end_inset

.
 The front-end takes the program code and creates an abstract representation
 of it, and the back-end takes that representation and converts it into
 the target language.
\end_layout

\begin_layout Section
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the first part of the front-end, and is the process
 by which the compiler takes the program code in the form of an input string,
 and parses it into a list of separate tokens, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
lexemes
\end_layout

\end_inset

, which are the smallest significant components in a programming language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book1.2"

\end_inset

.
\end_layout

\begin_layout Standard
For example, given a program in a simple language with Haskell-like syntax
 with a source code that looks like this:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fun x y = x + y
\end_layout

\end_inset


\end_layout

\begin_layout Standard
a lexer could generate a list of tokens in this vein:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[fun,x,y,=,x,+,y]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Parsing
\end_layout

\begin_layout Standard
Parsing is the second part of the front-end and takes the list of lexemes
 and interprets it according to a grammar, creating a data structure containing
 an abstract representation of the code, called the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
abstract syntax tree
\end_layout

\end_inset

.
 The abstract syntax tree is a tree (or tree-like) graph with nodes representing
 the application of a certain rule in the grammar.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename adsgadgs.png
	lyxscale 50
	width 14cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graphic representation of an AST of a function definition in a simple language
 with Haskell- like syntax.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Semantic analysis
\end_layout

\begin_layout Standard
Semantic analysis gathers various semantic properties of the source program,
 to check for errors and to use later on in the compilation process.
 One common part of semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type checking
\end_layout

\end_inset

, where the compiler searches the abstract syntax tree for type inconsistencies.
 For example, in many languages, adding a boolean to an integer is not a
 valid expression, an error which would be caught by the type checker.
 Another common part of the semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
name checking
\end_layout

\end_inset

, where the compiler checks whether there are any ambiguities in variable
 names used, and whether used variables are in scope where they are used.
\end_layout

\begin_layout Standard
Other operations on the syntax tree, such as reduction of complex constructs
 into simpler, more general constructs can also be done as part of the semantic
 analysis.
 This is done to simplify the code generation process.
 Some code optimizations that are independent of the target language used
 can also be performed at this stage.
 
\end_layout

\begin_layout Section
Intermediate representation
\end_layout

\begin_layout Standard
After passing through the compiler front-end, the source program has been
 converted into an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
intermediate representation
\end_layout

\end_inset

, which will later be used as input for the back-end.
 The intermediate representation can take many forms, for example an abstract
 syntax tree, code in another high-level programming language, or some low-level
 code (for example three-address code)
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book1.2"

\end_inset

.
 
\end_layout

\begin_layout Section
Back-end
\end_layout

\begin_layout Standard
The back-end is the final part of the compiler.
 The main function of the back-end is code generation, which is the process
 of taking the intermediate representation and producing a semantically
 equivalent program in the target language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book8"

\end_inset

.
 The back-end can also fill other functions such as performing code optimization
s that are specific to the target language.
 
\end_layout

\begin_layout Chapter
Method
\end_layout

\begin_layout Standard
The main part of this project is the development of the compiler itself.
 This task is performed by first implementing a working compiler for a small
 subset of Haskell.
 This smaller compiler is then tested and expanded iteratively, until full
 support for the Haskell specification 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 has been achieved.
\end_layout

\begin_layout Standard
<TODO: redo this completely as this is simply not true >
\end_layout

\begin_layout Standard
<TODO: read some articles on what to put here>
\end_layout

\begin_layout Standard
<TODO: Something about chosing to implement JSHC without using implementation
 details of existing compilers for Haskell>
\end_layout

\begin_layout Section
Coding standard
\end_layout

\begin_layout Standard
In 
\end_layout

\begin_layout Section
Tools and libraries used
\end_layout

\begin_layout Standard
Several external tools were used to facilitate the development of JSHC.
 
\end_layout

\begin_layout Subsection
PEG.js
\end_layout

\begin_layout Standard
PEG.js
\begin_inset CommandInset citation
LatexCommand cite
key "peg-js"

\end_inset

 is a JavaScript implementation of parsing expression grammars, which is
 an alternative to context-free grammars and regular expressions for defining
 formal languages
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

.
 The definition of a parsing expression grammar is similar in appearance
 to that of a context-free grammar, with a few key differences.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
unordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
|
\end_layout

\end_inset

 is replaced by an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
ordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
/
\end_layout

\end_inset

.
 This means that, instead of accepting a match on any rule in a production,
 a parsing expression grammar always accepts the first rule matched.
 This means that parsing expression grammars are inherently unambiguous.
 If there are two possible matches to a rule, simply match the one that
 occurred first.
 
\end_layout

\begin_layout Standard
Parsing expression grammars also have several operators similar to those
 used in regular expressions.
 There are the repetition operators 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

 which matches zero or more repetitions of a rule, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 which matches one or more repetitions of a rule.
 There is also the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
?
\end_layout

\end_inset

 operator which eiter matches a rule and returns it, or does not match it
 and returns an empty match.
 Just as with the ordered choice, these operators take a greedy approach,
 i.e.
 they always consume the maximum amount of input possible.
 
\end_layout

\begin_layout Standard
Lastly, parsing expression grammars feature the syntactic predicates 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

.
 These match their paired rule, and either fail or succeed without advancing
 the parser position.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 returns an empty match if the match is successful and fails otherwise,
 while 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

 returns an empty match if the match fails and succeeds otherwise.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
PEG.js generates a Packrat
\begin_inset CommandInset citation
LatexCommand cite
key "ford-packrat"

\end_inset

 parser, i.e.
 a top-down recursive descent parser with backtracking.
 To avoid a worst-case scenario of exponential runtime, packrat parsers
 store intermediate results in a table, sacrificing storage space for guaranteed
 linear-time complexity.
 
\end_layout

\begin_layout Standard
PEG.js was chosen for this project due to the suitability of parsing expression
 grammars for writing lexical analysers 
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

 in a concise and intuitive way, as well as for the efficiency of packrat
 parsers.
 
\end_layout

\begin_layout Subsection
Jison
\end_layout

\begin_layout Standard
Jison is a parser generator for generating JavaScript parsers.
 It takes a context-free grammar in the same format as the input files to
 Bison, apart for parser actions, which are defined in the implementation
 language, which is JavaScript for Jison and C for Bison.
 Just like Bison, the parser generated by Jison is LALR(1) by default
\begin_inset CommandInset citation
LatexCommand cite
key "jison,bison-manual"

\end_inset

, which is the option used for the parser in JSHC.
 
\end_layout

\begin_layout Standard
Jison was chosen mainly because of the familiarity and extensive documentation
 of the Bison notation and functionality, as well as for its powerful constructs
 for handling user-defined error handling, something which is essential
 to a Haskell parser 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report10.3"

\end_inset

.
 The speed and compact size of LALR parsers were also taken into account,
 but not critical for the choice.
 
\end_layout

\begin_layout Subsection
Ymacs
\end_layout

\begin_layout Standard
As a graphical interface to JSHC, a JavaScript-based Emacs-like text editor
 named Ymacs
\begin_inset CommandInset citation
LatexCommand cite
key "ymacs"

\end_inset

 was chosen.
 The main reasons for this choice were that Ymacs is easily extendable and
 is fully compatible with three of the most widely used web browsers (Mozilla
 Firefox, Google Chrome and Apple Safari
\begin_inset CommandInset citation
LatexCommand cite
key "browser-statistics"

\end_inset

).
 Also, Emacs is a popular coding environments among Haskell programmers
\begin_inset CommandInset citation
LatexCommand cite
key "state-of-haskell"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Ymacs interface consists of a window with one or more buffers for entering
 text.
 <TODO: structure of Ymacs>
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
Custom built test suite 
\end_layout

\begin_layout Standard
<TODO: how and what do we test?>
\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard
<TODO: write an introduction>
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
Interface
\end_layout

\begin_layout Standard
An interface for using the compiler has been created.
 It uses Ymacs to allow a user to create modules and then load them in an
 interpreter that uses the compiler.
\end_layout

\begin_layout Standard
<TODO: image of the interface with two files and the interpreter open>
\end_layout

\begin_layout Subsection
Ymacs
\end_layout

\begin_layout Standard
Several modifications has been done to the default Ymacs environment.
\end_layout

\begin_layout Subsubsection
Setting modes automatically
\end_layout

\begin_layout Standard
Since no mode is automatically set for new buffers, the creation of a new
 buffer has been modified so that it sets a mode for the buffer based upon
 what the extension of the name of the buffer is.
 This makes it possible to create a new buffer with a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.hs
\end_layout

\end_inset

 extension, and the haskell mode will be set.
\end_layout

\begin_layout Subsubsection
Haskell mode
\end_layout

\begin_layout Standard
A haskell mode for buffers containing haskell code.
 It currently only contains the command 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C-x i
\end_layout

\end_inset

to show the interpreter.
 If the interpreter is visible in a frame, the focus will be changed to
 that buffer, otherwise the current frame is split show it.
 There can only be a single interpreter buffer, so a new interpreter buffer
 is only created if it does not exist.
\end_layout

\begin_layout Subsubsection
Interpreter mode
\end_layout

\begin_layout Standard
To modify an ordinary buffer into a terminal, the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ENTER
\end_layout

\end_inset

 key is a Ymacs command that will read the last line of the buffer send
 the command on the line to the interpreter.
 The 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
TAB
\end_layout

\end_inset

 key is a Ymacs command that sends the command on the last line to the interpret
er, and the buffer is modified depending on if there is none, one, or many
 matches.
\end_layout

\begin_layout Standard
The highlighting for the buffer is coloring lines beginning with 
\begin_inset Quotes eld
\end_inset

Error: 
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

> 
\begin_inset Quotes eld
\end_inset

 to make output easier to read.
\end_layout

\begin_layout Standard
When an interpreter buffer is created, the buffer object itself is modified
 to only allow deletions of characters and selections on the user input
 on the last line, and insertion of text is modified so that text is always
 added at the end of the buffer.
 These changes are achieved by replacing existing functions on the buffer
 with new functions that calls the old ones when appropriate.
\end_layout

\begin_layout Subsection
Interpreter
\end_layout

\begin_layout Standard
The interpreter supports a subset of the GHCi commands, and includes a command
 for evaluation of javascript expressions.
\end_layout

\begin_layout Standard
The following commands are available.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="4.5in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
command
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:help
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints available commands
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:kind
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes any number of type constructors and prints the kind of each
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:load
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a number of module names of modules to load.
 Will find all dependencies and recompile modules as necessary.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the possible arguments to :show
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a Haskell expression which will be compiled.
 If it has no errors, the type of the expression will be printed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:js
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a Javascript expression and evaluates it.
 If it has no errors, the result will be printed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show path
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the URLs which will be used when loading Haskell modules.
\end_layout

\begin_layout Plain Layout
The default paths are 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hslib/
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hsusr/
\end_layout

\end_inset

 from the root of the source distribution.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the generated Javascript code of all loaded Haskell modules.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show modules
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the names of the currently loaded modules.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Interpreter commands
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Dependency groups
\end_layout

\begin_layout Standard
The implementation for handling dependency groups takes a set of entries,
 where each entry provides a set of names, depends on a set of names, and
 contains a set of items, such as modules or declarations.
\end_layout

\begin_layout Standard
These entries will have to be created from the declarations or modules that
 one will want to create dependency groups for.
\end_layout

\begin_layout Standard
The entries are nodes in a graph where the minimal number of entries are
 merged such that there are no longer any cycles in the graph.
\end_layout

\begin_layout Subsection
Condensing the graph
\end_layout

\begin_layout Standard
Given a directed graph representing the dependencies, it merges the minimal
 amount of nodes to create a directed acyclic graph.
 This takes O(|E|+|V|) time.
\end_layout

\begin_layout Standard
<TODO: pseudo code for condensing the graph?>
\end_layout

\begin_layout Standard
<TODO: time and space analysis>
\end_layout

\begin_layout Subsection
Dependency order traversal
\end_layout

\begin_layout Standard
Traversing the graph of the groups in dependency order.
\end_layout

\begin_layout Standard
The algorithm computes the ordering lazily, similar to an iterator, but
 allows for concurrency by producing a set of nodes at each step.
\end_layout

\begin_layout Standard
<TODO: pseudo code here?>
\end_layout

\begin_layout Section
Compiler front-end
\end_layout

\begin_layout Standard
<TODO: proper introduction here>
\end_layout

\begin_layout Itemize
Find, read and parse all modules: This part identifies the modules used,
 performs lexical analysis on them and parses them into an abstract representati
on of the language, the Abstract Syntax Tree (AST).
\end_layout

\begin_layout Itemize
Type checking: This part consists of checking each module for type correctness,
 as well as inferring general types.
 This new inferred type information is added to the AST.
\end_layout

\begin_layout Itemize
Simplification: Before compilation, the AST is simplified, reducing the
 number of different constructs used, to make for easier compilation.
\end_layout

\begin_layout Subsection
Loading modules
\end_layout

\begin_layout Standard
The loading begins with the module names of a set of modules to load, and
 will search for them in a virtual file system (mapping from module names
 to unparsed strings), a list of URLs (which can refer to files using the
 file:// or http:// protocols).
 Each found module must be parsed in order to find out which modules it
 depends upon.
 Those modules (unless already loaded) must then be found and parsed as
 well.
 This process continues until no more modules are needed, and the minimal
 set of modules that satisfies all the module dependencies has been found.
 In case a module can not be found or there is a parse error, this process
 will still continue and try to satisfy more dependencies and see if there
 are more missing modules or parse errors.
\end_layout

\begin_layout Subsubsection
Lexical analysis
\end_layout

\begin_layout Standard
The lexical analysis in JSHC is performed in several steps.
 <TODO: a good way to init this section?>
\end_layout

\begin_layout Standard
While lexical analysis is often done by having the parser request a token
 from the lexical analyser, match that token against a rule, request another
 and so on
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book3.1"

\end_inset

, the layout-dependent syntax of Haskell requires a different approach.
 First, the input (i.e.
 the Haskell source code, including whitespace and comments) is parsed into
 an array of tokens in one go.
 This is done by using a parser built using PEG.js that was fed a translation
 (into PEG.js-readable form) of the lexical program structure described in
 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report2.2"

\end_inset

.
 Second, the generated array of tokens is run through a function that adds
 indentation information to the array in the form of special indentation
 tokens, and annotates tokens with position information.
 Whitespace and comments are discarded as they are no longer needed for
 position information.
 Lastly, this array is fed into an object which interfaces with the parser
 according to the Jison/Bison style API
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book3.1"

\end_inset

, using the indentation information to generate tokens to convert Haskell's
 layout-dependent syntax into a context-free one.
 
\end_layout

\begin_layout Standard
As an example, the code: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f = let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x = 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

y = 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
generates, after the first and second stages this array of tokens (token
 representation rewritten for readability):
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[{1},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

let
\begin_inset Quotes erd
\end_inset

,{3},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,
\begin_inset Quotes erd
\end_inset

in
\begin_inset Quotes erd
\end_inset

,ID,OP,ID]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where the tokens 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{n}
\end_layout

\end_inset

 designate the start of a block after a newline and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
<n>
\end_layout

\end_inset

 representing a newline where a new block should not begin.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
n
\end_layout

\end_inset

 represents the starting column of the first token on the new line.
 Given this array as input, the last stage of the lexer will deliver to
 the parser tokens representing a context-free version of the code which,
 converted back into Haskell source code, would look like this:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{f = let {x = 1;y = 2} in x + y}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parsing
\end_layout

\begin_layout Standard
The context-free syntax is parsed by a parser implemented using the JISON
 parser generator 
\begin_inset CommandInset citation
LatexCommand cite
key "jison"

\end_inset

.
 The parser and the last step of the lexical analysis work in concert, meaning
 that the lexical analyser does not process and return all tokens in one
 go, but only sends the parser tokens when asked to.
 To handle certain features of the layout dependent syntax of Haskell, that
 cannot be handled by the lexical analyser alone, the parser will inform
 the lexical analyser of any such parse errors, so that the lexer can react
 and send new tokens that solve the problem (c.f.
 the description of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
parse-error
\end_layout

\end_inset

 function in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report10.3"

\end_inset

).
 
\end_layout

\begin_layout Standard
<TODO: create figure explaining the layout of finding/lexing/parsing>
\end_layout

\begin_layout Subsection
Checking dependency groups of modules
\end_layout

\begin_layout Standard
The following steps are taken for each group of modules, which are checked
 in dependency order.
\end_layout

\begin_layout Itemize
Export check: Computes the export space of each module
\end_layout

\begin_layout Itemize
Name check: Checks if names are in scope, and qualifies names referring
 to top-level declarations
\end_layout

\begin_layout Itemize
Fixity resolution: Replace all lists of infix applications with operator
 application
\end_layout

\begin_layout Itemize
Type check: Compute types and kinds
\end_layout

\begin_layout Subsubsection
Export check
\end_layout

\begin_layout Standard
The implementation gives an error if modules in the same group have a list
 of exports, as this is currently not supported.
 If the modules do not have a list of exports, all top-level declarations
 are exported, which is easy to handle, and is only what is currently supported.
 If there is only a single module in a group, then the export list may exist
 and the exported names are resolved by looking at all top-level declarations
 and imports.
\end_layout

\begin_layout Subsubsection
Name check
\end_layout

\begin_layout Standard
This is applied separately on each module in a group.
\end_layout

\begin_layout Standard
Errors is given for missing and ambiguous names.
 Otherwise the name will be qualified with the qualification of what it
 refers to so that the definition can easily be found later on when it is
 non-local.
 The definition needs to be found later on when fixity and type information
 is required.
\end_layout

\begin_layout Subsubsection
Fixity Resolution
\begin_inset CommandInset label
LatexCommand label
name "sub:Fixity-Resolution"

\end_inset


\end_layout

\begin_layout Standard
Applied separately on each module in a group.
\end_layout

\begin_layout Standard
Given the available operators and their precedences, adjusts the expressions
 in all functions and operators so that they use the declared precedence.
\end_layout

\begin_layout Subsubsection
Type checking
\end_layout

\begin_layout Standard
The monomorphism restriction (see 4.5.5 in the report) is not implemented.
\end_layout

\begin_layout Standard
Since type classes are not implemented, the type system only implements
 the parametric polymorphism.
\end_layout

\begin_layout Standard
Type checking is applied on dependency groups over all declarations from
 all modules in the group, since one can not check the top-level declarations
 of a single module in dependency order as they may depend on types from
 top-declarations in other modules within the same group.
\end_layout

\begin_layout Standard
While type checking, the algorithm keeps track of local names and type variables
, and also the constraints using a map from the type variables to types
 to which they are contrained.
\end_layout

\begin_layout Standard
*** The constrain map
\end_layout

\begin_layout Standard
The constraint map maps type variables (LHS) to types (RHS).
\end_layout

\begin_layout Standard
It simply represents the types that type variables are contrained to.
\end_layout

\begin_layout Standard
Type variables are only given a type if they are constrained, so all new
 type variables will not be in the map until a constraint is placed upon
 them.
\end_layout

\begin_layout Standard
Type variables on the LHS may not occur in their corresponding RHS as this
 would create an infinite type, and may only occur in the RHS of other variables
 if the other RHSs are such that there is no infinite type.
 This invariant is maintained when new constrained are inserted.
\end_layout

\begin_layout Standard
The reason for using a constraint map is that type errors are discovered
 as soon as possible, so a type error in a sub-expression will be given
 for the sub-expression instead of the expression as a whole if the constraints
 were just gathered and then checked after computing all of them, which
 is the usual description of solving the constraints <reference to 
\begin_inset Quotes eld
\end_inset

Pierce, B.
 C.
 2002 Types and Programming Languages.
 MIT Press.
\begin_inset Quotes erd
\end_inset

 chapter 22 or so>
\end_layout

\begin_layout Standard
*** Adding constraints
\end_layout

\begin_layout Standard
<TODO: describe what happens when adding constraints such as 
\begin_inset Quotes eld
\end_inset

a -> b = c -> d
\begin_inset Quotes erd
\end_inset

.
 Will be split into two separate constraints, which will each cause elimination
 of a type variable as the constraint specifies that two constraints are
 equal.>
\end_layout

\begin_layout Standard
*** Checking a group of declared names
\end_layout

\begin_layout Standard
Each declared name in a group is given a type variable.
 As the declarations are checked, the type variables for the names will
 be constrained depending on what the declaration contains.
 After all declarations in the group have been checked, all free type variables
 occuring in the types bound to the type variables of each declared name
 are quantified since they only occur inside the declarations.
\end_layout

\begin_layout Standard
*** Checking declarations
\end_layout

\begin_layout Standard
<TODO: Probably need a few concrete examples.
 Should be done in a similar way to as it was done in the theory chapter,
 but need to show the constraint map.
 need to give example of nested let-declarations to show the point of it
 all.>
\end_layout

\begin_layout Standard
It is necessary to use dependency groups and check in dependency group order
 to give the correct type, instead of checking all of the declarations as
 a single group <TODO: example needed.
 check the haskell report.
 related to the monomorhism restriction.>
\end_layout

\begin_layout Standard
Checks for missing identifiers (type variables, types, functions, etc..),
 instances, and infer type.
 Adds type information to the AST.
\end_layout

\begin_layout Subsection
Reduction of syntax tree
\end_layout

\begin_layout Standard
This step translates the AST to the intermediate representation used by
 the back-end, see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:B.2Intermediate-representation"

\end_inset

 for details.
 Several constructs are reduced to other, simpler and more general, constructs
 to create a kernel, which is a small subset of Haskell.
 The constructs that can be reduced in this way syntactic sugar of the kernel
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report1.2"

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Conditional expressions
\end_layout

\begin_layout Standard
Conditional expressions are converted into 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

expressions, with two alternatives 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
linebreak
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True -> exp
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
False -> exp
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
This means that the expression: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if x > y then 1 else 0
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as the expression:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case x > y of
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

True -> 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

False -> 2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Let and where expressions
\end_layout

\begin_layout Standard
Since what 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expressions do is bind expressions to local variables, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions have this capability as well, they are converted to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions.
 The right hand sides of the local declarations are inserted into a tuple
 expression, and the left hand sides are put in a tuple pattern.
 The tuple expression is then matched to the tuple pattern inside a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expression, thus causing them to be bound to each other.
\end_layout

\begin_layout Standard
As an example, the expression:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x = 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

y = 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as the expression: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case (1,2) of
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(x,y) -> x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Pattern matching
\end_layout

\begin_layout Standard
Pattern matching in function definitions follows the same rules as in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions, so a simplification is performed here.
 For each alternative match of the function, the arguments are wrapped in
 a tuple pattern and paired with their corresponding right hand side to
 create 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 alternatives.
 Then, the function is given dummy arguments, to preserve its arity.
 A 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expression is then created which matches a tuple expression with the function's
 arguments against the newly created 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 alternatives.
 
\end_layout

\begin_layout Standard
For example, the function: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f True x = x + 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f False x = x - 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as this function:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f a1 a2 = case (a1,a2) of 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(True, x) -> x + 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(False, x) -> x - 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Function declarations
\end_layout

\begin_layout Standard
Function declarations with arguments are converted into a binding from the
 function name to a sequence of lambda expressions corresponding to the
 arity of the function.
\end_layout

\begin_layout Standard
For example, the function:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f x y = x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as the function:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f = 
\backslash
x -> 
\backslash
y -> x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
List expressions
\end_layout

\begin_layout Standard
List expressions are converted into applications of the list datatype, so
 that the list 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[1,2,3]
\end_layout

\end_inset

 is converted into 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
((:) 1 ((:) 2 ((:) 3 [])))
\end_layout

\end_inset

.
 Note that the cons operator is written in prefix notation, as an ordinary
 data constructor, instead of as an infix constructor, as is normally done
 when writing source code.
 This is because at this stage operator applications have already been removed
 from the language by the fixity resolution algorithm described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Fixity-Resolution"

\end_inset

.
 
\end_layout

\begin_layout Section
Compiler back-end
\end_layout

\begin_layout Standard
JSHC's back-end takes an intermediate representation in the form of an AST
 and compiles it to JavaScript code.
 
\end_layout

\begin_layout Subsection
Code generation
\end_layout

\begin_layout Standard
Generates javascript code representing the compiled modules.
 Compiles a program in the intermediate language to javascript, which can
 then be executed by any javascript interpreter.
\end_layout

\begin_layout Standard
Can be compiled so that all exported identifiers would use the same name
 in javascript (under some namespace), which allows easy lookup of identifiers
 by an interpreter, but also debugging of the compiler.
 <TODO: this is too short>
\end_layout

\begin_layout Subsection
Internal libraries
\end_layout

\begin_layout Standard
To support some of the 
\end_layout

\begin_layout Section
Standard libraries
\end_layout

\begin_layout Standard
The standard libraries used for JSHC are a subset of the libraries described
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

.
\end_layout

\begin_layout Chapter
Discussion
\end_layout

\begin_layout Section
Implementation details
\end_layout

\begin_layout Subsection
Export checking
\end_layout

\begin_layout Standard
It is unclear to us what is the best way of computing the set of exported
 names within dependency groups of modules.
\end_layout

\begin_layout Standard
Resolving exports is complicated.
 The haskell report only explains the syntax and semantics of export lists.
\end_layout

\begin_layout Standard
Example of a missing name:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module A ( x ) where
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import B
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module B ( x ) where
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import C
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module C ( x ) where
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import A
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Names could also be ambiguous.
\end_layout

\begin_layout Subsection
Dependency checking
\end_layout

\begin_layout Standard
The dependency checking was not expected.
 It is something which one does not see as a Haskell user.
 It is not needed in many other languages as they do not have cyclic dependencie
s between language constructs together with a lack of specification.
 It is this combination that causes the groups that need to be analysed
 together instead of simple using an export specification of a module or
 a declared type of a function.
\end_layout

\begin_layout Section
Design choices
\end_layout

\begin_layout Section
Comparison with other implementations
\end_layout

\begin_layout Subsection
Other possible solutions to client-side Haskell
\end_layout

\begin_layout Standard
If making a plug-in, one still required writing a back-end to javascript
 and implementing an FFI to Javascript code.
\end_layout

\begin_layout Standard
If compiling an existing compiler like GHC to Javascript, it would require
 an existing Javascript back-end, and the performance of it would be important.
 There seems like there would be issues with how I/O is used within the
 compiler since it is not available in Javascript, which would mean that
 the compiler need to be modified and can not just be compiled as is.
\end_layout

\begin_layout Subsection
GHC
\end_layout

\begin_layout Standard
<TODO: Anything to write here?>
\end_layout

\begin_layout Subsection
HIJi (project from previous year)
\end_layout

\begin_layout Standard
From the report, it is unclear if one can load more than one module, and
 if cyclies in the dependencies of module and declaration are handled as
 it is not mentioned.
\end_layout

\begin_layout Section
Future work on JSHC
\end_layout

\begin_layout Subsection
Loading files asyncronuously
\end_layout

\begin_layout Standard
This is not difficult, but since only local files or files on the same domain
 may be accessed, there does not appear to be a reason to implement this.
\end_layout

\begin_layout Subsection
Pretty printer
\end_layout

\begin_layout Standard
To give good error messages related to expressions within functions, a pretty
 printer is required.
 Currently, only the abstract syntax tree is available.
\end_layout

\begin_layout Subsection
Concurrency
\end_layout

\begin_layout Standard
The dependency group traversal could run concurrently, as the implemented
 algorithm allow for taking out many groups which do not depend on each
 other.
 Even though extensions for concurrency exists, speed is not important in
 the compiler in it
\begin_inset Quotes ers
\end_inset

s current state.
\end_layout

\begin_layout Subsection
FFI: Foreign Function Interface
\end_layout

\begin_layout Standard
Adding an FFI to Javascript code would simplify the writing of thePprelude,
 as primitive operations such as addition could be described using foreign
 imports instead of a name with a special prefix for which the type would
 be stored in the type checker when looking up the name instead of the type
 being written in a foreign function declaration.
\end_layout

\begin_layout Standard
More importantly, it will also allow writing Haskell libraries that wrap
 Javascript APIs.
\end_layout

\begin_layout Subsection
Type classes
\end_layout

\begin_layout Standard
reference to 
\begin_inset Quotes eld
\end_inset

Type classes in Haskell Cordelia Hall, Kevin Hammond, Simon Peyton Jones,
 and Philip Wadler.
 European Symposium On Programming, LNCS 788, Springer Verlag, pp.
 241-256, April 1994.
\begin_inset Quotes erd
\end_inset

 from http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
\end_layout

\begin_layout Subsection
Highlighting in the Haskell mode
\end_layout

\begin_layout Section
Issues
\end_layout

\begin_layout Subsection
The Haskell grammar
\end_layout

\begin_layout Standard
The grammar in the Haskell report is at least an LR(2) grammar as it requires
 a lookahead of 2 when reading topdeclarations, and it has conflicts as
 an LALR grammar.
 This means that it must be rewritten for a LALR(1) parser generator such
 as Jison.
 The grammar is also ambiguous <TODO: for example something related to an
 empty file?>.
 We do not think the grammar should be ambiguous, as it makes it less clear
 and also harder to implement a parser for.
\end_layout

\begin_layout Standard
Other issues.
 e.g 
\begin_inset Quotes eld
\end_inset

2=3
\begin_inset Quotes erd
\end_inset

 should not be a valid declaration in the grammar.
\end_layout

\begin_layout Standard
The conflict messages in Jison (and also Bison) are not easy to understand.
 Better explanations of conflicts in these tools is certainly possible.
\end_layout

\begin_layout Subsection
Bugs
\end_layout

\begin_layout Subsection
Interpreter: accessing URLs
\end_layout

\begin_layout Standard
The idea was that the interpreter should support adding paths.
 Unfortunately, the most common browsers prevent getting files from domains
 other than the one that the script is executed on.
 If using chrome/chromium, the security policy even prevents accessing local
 files using the file:// protocol when running scripts from local files,
 so the Ymacs interface must be placed on a webserver to work for browsers
 with such a restriction.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "jshc"
options "plain"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Nomenclature
\end_layout

\begin_layout Chapter
Syntax reference
\end_layout

\begin_layout Standard
Detailed in this appendix is a reference to the subset of the Haskell syntax
 supported by JSHC, as well as the intermediate representation used by the
 code generation.
 
\end_layout

\begin_layout Section
Context-free syntax
\end_layout

\begin_layout Standard
The same notational convention used in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 is used here, i.e:
\end_layout

\begin_layout Standard
[pattern] : optional
\end_layout

\begin_layout Standard
{pattern} : zero or more repetitions
\end_layout

\begin_layout Standard
(pattern) : grouping
\end_layout

\begin_layout Standard
pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 | pat
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
nonterm -> alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 | alt
\begin_inset Formula $_{\text{2}}$
\end_inset

 | … | alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 : production
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module → module modid [exports] where body 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| body
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body → { impdecls ; topdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { impdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { topdecls }
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecls → impdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; impdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exports → ( export
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , export
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
export → qvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycon [(..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycls [(..) | ( qvar
\begin_inset Formula $_{\text{1}}$
\end_inset

, … , qvar
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| module modid
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecl → import modid [impspec]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (empty declaration)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impspec → ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| hiding ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tycon [ (..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

)] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
cname → var | con
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls → topdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; topdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl → type simpletype = type
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| data simpletype [= constrs]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| decl
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decls → { decl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; decl
\begin_inset Formula $_{\text{n}}$
\end_inset

 } 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl → gendecl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (funlhs | pat) rhs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gendecl → vars :: type 
\end_layout

\end_inset

(type signature)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fixity [integer] ops 
\end_layout

\end_inset

(fixity declaration)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| 
\end_layout

\end_inset

(empty declaration)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ops → op
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , op
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
vars → var
\begin_inset Formula $_{\text{1}}$
\end_inset

 , …, var
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fixity → infixl | infixr | infix
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
type → btype [-> type] 
\end_layout

\end_inset

(function type)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
btype → [btype] atype 
\end_layout

\end_inset

(type application)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
atype → gtycon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tyvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , type
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple type, k ≥ 2)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ type ] 
\end_layout

\end_inset

(list type)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type ) 
\end_layout

\end_inset

(parenthesized constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gtycon → qtycon
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
simpletype → tycon tyvar
\begin_inset Formula $_{\text{1}}$
\end_inset

 … tyvar
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(k ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constrs → constr
\begin_inset Formula $_{\text{1}}$
\end_inset

 | … | constr
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constr → con [!] atype
\begin_inset Formula $_{\text{1}}$
\end_inset

 … [!] atype
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(arity con = k, k ≥ 0)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
funlhs → var apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| pat varop pat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( funlhs ) apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
rhs → = exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp → infixexp :: type 
\end_layout

\end_inset

(expression type signature)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| infixexp 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
infixexp → lexp qop infixexp 
\end_layout

\end_inset

(infix operator application)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| - infixexp 
\end_layout

\end_inset

(prefix negation)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| lexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lexp → 
\backslash
 apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{n}}$
\end_inset

 -> exp 
\end_layout

\end_inset

(lambda abstraction, n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| let decls in exp 
\end_layout

\end_inset

(let expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| if exp [;] then exp [;] else exp 
\end_layout

\end_inset

(conditional)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| case exp of { alts } 
\end_layout

\end_inset

(case expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fexp → [fexp] aexp 
\end_layout

\end_inset

(function application)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
aexp → qvar 
\end_layout

\end_inset

(variable)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon 
\end_layout

\end_inset

(general constructor)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp ) 
\end_layout

\end_inset

(parenthesized expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple, k ≥ 2)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ] 
\end_layout

\end_inset

(list, k ≥ 1)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts → alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt → pat -> exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat → lpat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lpat → apat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(arity gcon = k, k ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
apat → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon 
\end_layout

\end_inset

(arity gcon = 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| _ 
\end_layout

\end_inset

(wildcard)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat ) 
\end_layout

\end_inset

(parenthesized pattern)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , pat
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple pattern, k ≥ 2)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
var → varid | ( varsym ) 
\end_layout

\end_inset

(variable)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvar → qvarid | ( qvarsym ) 
\end_layout

\end_inset

(qualified variable)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
con → conid | ( consym ) 
\end_layout

\end_inset

(constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qcon → qconid | ( gconsym ) 
\end_layout

\end_inset

(qualified constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varop → varsym | ` varid ` 
\end_layout

\end_inset

(variable operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvarop → qvarsym | ` qvarid ` 
\end_layout

\end_inset

(qualified variable operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
conop → consym | ` conid ` 
\end_layout

\end_inset

(constructor operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qconop → gconsym | ` qconid ` 
\end_layout

\end_inset

(qualified constructor operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
op → varop | conop 
\end_layout

\end_inset

(operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qop → qvarop | qconop 
\end_layout

\end_inset

(qualified operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gconsym → : | qconsym 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Intermediate representation
\begin_inset CommandInset label
LatexCommand label
name "sec:B.2Intermediate-representation"

\end_inset


\end_layout

\begin_layout Standard
For detailing the intermediate representation, these notational conventions
 are used:
\end_layout

\begin_layout Standard
node → { item
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , item
\begin_inset Formula $_{\text{n}}$
\end_inset

}
\end_layout

\begin_layout Standard
item → name: value | [name: value]
\end_layout

\begin_layout Standard
rule
\begin_inset Formula $_{\text{1}}$
\end_inset

 | rule
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
name : the name of a n item inside a node
\end_layout

\begin_layout Standard
value : the value of an item inside a node, values can be both terminals
 and nonterminals
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module -> {name: "module",modid: <modname>, body: <body>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body -> {name: "body", topdecls: <topdecls>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls -> <topdecl>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <topdecl>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl -> {name: "topdecl-decl", decl: <decl>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl -> {name: "decl-fun", ident: <varname>, rhs: exp}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exps -> <exp>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <exp>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp -> {name: "lambda", args: <args>, rhs: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "case", exp: <exp>, alts: <alts>}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "application", exps: <exps>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple", members: <exps>}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
At this stage, it is legal for a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple-pat
\end_layout

\end_inset

 to have 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
members.length == 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "negate", exp: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts -> <alt>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <alt>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt -> {name: "alt", pat <pat> exp: <exp>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pats -> <pat>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <pat>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat -> {name: "conpat", con: dacon, pats: <pats>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple-pat", members: <pats>} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{1}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "wildcard"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
modname -> {name: "modname", id: dacon}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon -> {name: "dacon", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
loc
\end_layout

\end_inset

 is used to determine whether a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname
\end_layout

\end_inset

 is qualified, and what that qualification is.
 At this stage, anything that is not qualified is a local variable.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname -> {name: "varname", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{2}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
literal -> {name: "integer-lit", val: <STRING>} 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
STRING -> a javascript String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
NUMBER -> a javascript Number
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<TODO: some significant pieces of the source code, test cases, etc..
 probably an example of how the compiler can be used on a web page>
\end_layout

\end_body
\end_document
