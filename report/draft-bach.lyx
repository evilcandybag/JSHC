#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
\myTOC
\clearpage
\pagenumbering{arabic}
}
\end_preamble
\use_default_options true
\begin_modules
logicalmkup
\end_modules
\language english
\inputencoding utf8-plain
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Modern web applications are becoming more and more complex, with users expecting
 more and more automation of menial tasks such as spelling correction and
 autocompletion of text.
 This leads to web applications becoming larger and more complex, which
 in turn means that they are becoming more error prone<TODO: reference?>.
 One large source of errors in web applications is the absence of type safety
 in the form of static type checking in most scripting languages aimed at
 web development, such as JavaScript or PHP <TODO: reference? A Type System
 for Dynamic Web Documents has some stuff, then the Curry stuff can be useful>.
 One solution to this problem is providing an extra layer of abstraction
 on top of these scripts, that in turn can be subject to static type checking.
 For example another, already existing, programming language that has these
 features can be used.
 
\end_layout

\begin_layout Standard
Haskell is one such language, designed with type-safety as one of the major
 concerns <TODO:ref: ?>.
 By compiling Haskell directly to JavaScript, we use its strong type system
 to guard against some of the errors that are hard to avoid when writing
 large and complex application with a dynamically typed language such as
 JavaScript.
 <TODO: better formulation plox> 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Using Haskell for type safe web-programming is not a new concept.
 Several different approaches have been suggested; the use of Haskell to
 model HTML
\begin_inset CommandInset citation
LatexCommand cite
key "HTML-in-haskell"

\end_inset

 and using server-side Haskell applications to generate CGI
\begin_inset CommandInset citation
LatexCommand cite
key "CGI-haskell"

\end_inset

 are two examples.
 Other languages similar to Haskell have also been suggested for type safe
 web-applications, such as the functional logic language Curry
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js"

\end_inset

.
 <TODO: stuffe here> there are several projects out there with a similar
 approach to the one presented here.
 Notable ones are Yesod 
\begin_inset CommandInset citation
LatexCommand cite
key "yesod-book"

\end_inset

, which is a full-featured web server framework, and YCR2JS 
\begin_inset CommandInset citation
LatexCommand cite
key "yhc-js"

\end_inset

, a JavaScript back end to the York Haskell Compiler.
 <TODO: elaborate here>
\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
The purpose of this thesis is to present an implementation of a fully JavaScript
 Haskell-compiler (i.e.
 a compiler written entirely in JavaScript, compiling Haskell to JavaScript).
 Coupled with the compiler will be an interface in the form of a JavaScript-base
d text editor with an interactive code console (in the vein of the Glasgow
 Haskell Compiler's GHCi).
 By writing the compiler entirely in JavaScript, all computations will be
 performed by the client, thus greatly lightening the server load compared
 to having the computations run server-side, while still saving the user
 the work of downloading a compiler to their computer.
 The compiler supports the a subset of Haskell, as described in .
 <TODO; rewrite as much of this is filthy LIES!>
\end_layout

\begin_layout Chapter
Introduction to Haskell
\end_layout

\begin_layout Standard
This chapter is intended as a quick but thorough introduction to Haskell
 for readers unfamiliar with or new to Haskell and/or functional languages.
 It consists of a very general overview, followed by separate sub chapters
 with details about specific features.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Haskell is a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
lazy
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
purely functional
\end_layout

\end_inset

 programming language with 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
strong static typing
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
type inference
\end_layout

\end_inset

.
 A program in Haskell consists of one or more modules, interconnected by
 their import and export specifications.
 The contents of a module is a set of top-level declarations, which can
 be, among others, function declarations, datatype declarations and typeclass
 declarations.
 Functions consist of a name, a set of arguments and an expression, that
 expresses the result of the function when applied to its arguments.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being lazy means that an expression is only evaluated when its result is
 needed.
 Any expression whose result is not used is simply ignored.
 This enables lazy languages to feature some things that are otherwise impossibl
e, such as infinite data structures.
 Since the data structure is lazy, only the part that is needed.
 For example, a list of infinite length can be described in Haskell using
 like so:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x = [1..]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This statement assigns to the variable x an expression that calculates an
 infinite list containing all integers > 0 in rising order.
 While an expression calculating this in a strict language would never terminate
 as the set of integers > 0 is infinite, a lazy language only calculates
 the needed parts, e.g:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
take 5 x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where take is a function that returns a list consisting of the first n elements
 in a list, only needs the first 5 elements of x, so no more than 5 elements
 are computed.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being purely functional, Haskell's functions do not have side effects.
 <TODO: more on purity>
\end_layout

\begin_layout Standard
Another feature of purely functional languages is that functions are first-class
 objects.
 This means that functions can be passed around as arguments to other functions,
 be returned as the result of a function or created at runtime.
 This enables the creation of 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
higher order functions
\end_layout

\end_inset

, generalized functions that use other functions as arguments.
 For example, the function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
filter
\end_layout

\end_inset

 from the Haskell standard libraries takes a function, which takes one argument
 and returns a boolean, and a list.
 The function then applies the supplied function to each element in the
 list and returns a new list with all elements for which the supplied function
 returned 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<TODO: type system>
\end_layout

\begin_layout Standard
Haskell’s module system is its main method of encapsulation.
 Apart from local variables in a certain function, it is the only way to
 determine whether something is known (i.e.
 in scope) or not.
 Each module has a name, a set of imports and a set of exports.
 The specification of these is optional, with defaults being “Main”, the
 empty import set and the export set containing all top-level declarations,
 respectively.
 
\end_layout

\begin_layout Section
Module system <TODO; need not be this much>
\end_layout

\begin_layout Standard
Haskell’s module system main method of encapsulation.
 Apart from local variables in a certain function, it is the only way to
 determine whether something is known (i.e.
 in scope) or not.
 Each module has a name, a set of imports and a set of exports.
 The specification of these is optional, with defaults being “Main”, the
 empty import set and the export set containing all top-level declarations,
 respectively.
 
\end_layout

\begin_layout Standard
Specification of module name and exports is done by the clause 
\end_layout

\begin_layout Standard

\family typewriter
module Name [(export
\begin_inset Formula $_{\text{}}$
\end_inset


\begin_inset Formula $1$
\end_inset

,..
 export
\begin_inset Formula $_{\text{}}$
\end_inset


\begin_inset Formula $n$
\end_inset

)] where 
\end_layout

\begin_layout Standard
where 
\family typewriter
Name
\family default
 is any number of identifiers starting with an uppercase letter, separated
 by points.
 The export specification, within square brackets, is optional and contains
 elements of the form 
\end_layout

\begin_layout Standard

\family typewriter
(f, module M, T) 
\end_layout

\begin_layout Standard
where 
\family typewriter
f
\family default
 is the name of a function, 
\family typewriter
M
\family default
 is the name of a module and 
\family typewriter
T
\family default
 is the name of an abstract datatype or typeclass.
 In English, the first item would mean “export the function known to this
 module with the name 
\family typewriter
f
\family default
”, the second item “export everything imported from the module 
\family typewriter
M
\family default
” and the third item “export the abstract datatype or typeclass known to
 this module with the name 
\family typewriter
T
\family default
”.
 Note that the third item only exports the name of the datatype or typeclass,
 not their respective members.
 This means that if we export a type 
\family typewriter
T
\family default
 with the definition
\end_layout

\begin_layout Standard

\family typewriter
data T = U | V 
\end_layout

\begin_layout Standard
without specifying its exports, the importing modules will not be able to
 access the constructors 
\family typewriter
U
\family default
 and 
\family typewriter
V
\family default
, only the type itself: 
\family typewriter
T
\family default
.
 This means that an importing module can write functions that take arguments
 or return values of type 
\family typewriter
T
\family default
, but not directly access its values (e.g.
 pattern matching).
 For importing modules to be able to access members of a datatype or typeclass,
 the exporting module can specify this in its export list like so: 
\end_layout

\begin_layout Standard

\family typewriter
(T(..), A(B,c)) 
\end_layout

\begin_layout Standard
where 
\family typewriter
T, A
\family default
 are abstract datatypes or typeclasses.
 In English, the first item would mean “export the abstract datatype or
 typeclass known to this module with the name 
\family typewriter
T
\family default
, as well as all of its members” and the second “export the abstract datatype
 or typeclass known to this module with the name 
\family typewriter
T
\family default
, as well as those of its members with the names 
\family typewriter
B
\family default
 and 
\family typewriter
c
\family default
”.
 
\end_layout

\begin_layout Standard
Import specification is done by clauses such as 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import A 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import B (f,g) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
import C hiding (f,g) 
\end_layout

\begin_layout Standard
where 
\family typewriter
A,B,C
\family default
 are module names.
 In English, the first line would mean 
\begin_inset Quotes eld
\end_inset

import from 
\family typewriter
A
\family default
 everything that it exports
\begin_inset Quotes erd
\end_inset

, the second line “import from 
\family typewriter
B
\family default
 only the exports 
\family typewriter
f
\family default
 and 
\family typewriter
g
\family default
” and the third line “import from 
\family typewriter
C
\family default
 everything that it exports, except 
\family typewriter
f
\family default
 and 
\family typewriter
g
\family default
”.
 
\end_layout

\begin_layout Standard
<TODO: put relevant theory here, to unclutter other chapters>
\end_layout

\begin_layout Section
Dependency groups
\end_layout

\begin_layout Standard
Since modules can mutually depend on each other, there can be a cycle in
 the dependencies between modules.
\end_layout

\begin_layout Standard
If a module A and a module B depends on each other by importing functions
 from the other module, one can not analyse one before the other, as the
 imported functions will be missing.
\end_layout

\begin_layout Standard
To solve this, one must analyse A and B together.
\end_layout

\begin_layout Standard
More generally, one creates a dependency group for any set of modules that
 creates a dependency cycle such as A depends on B, B depends on C, and
 C depends on A.
\end_layout

\begin_layout Standard
The dependency groups are the strongly connected components in the directed
 graph of dependencies between single modules.
\end_layout

\begin_layout Standard
After they have been computed, the resulting graph is a DAG (directed acyclic
 graph) where nodes are dependency groups, and the edges are the dependencies
 between the groups.
\end_layout

\begin_layout Standard
As there are no cycles in the dependencies between the groups, it is possible
 to traverse the groups in dependency order (a reverse topological ordering).
\end_layout

\begin_layout Standard
The Haskell standard 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 mentions dependency groups in Chapters 4.5.1, 4.5.2, and 4.6, related to different
 topics.
\end_layout

\begin_layout Standard
This concept is used in two places of the compiler.
 It is needed to describe sets of modules that depend on each other, sets
 of top-level declarations that depend on each other (even between different
 modules), and declarations in let/where expressions.
\end_layout

\begin_layout Standard
<TODO: perhaps an image of a few modules as an example.
 A->B->A, C->D->E->C, C->B, F->E, D->G.>
\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard
All values in haskell have a type.
\end_layout

\begin_layout Subsection
Polymorphic types
\end_layout

\begin_layout Standard
All types are rank-1 polymorphic types, which means that the type given
 to a value begins with a quantification of all the type variables that
 occur in it, followed by the rest of the type.
 <TODO: is it reasonable to assume that the reader knows what a type variable
 is?>
\end_layout

\begin_layout Standard
This means that the type of (:) which is "a -> [a] -> [a]" is actually "
\backslash
u2200a.
 a -> [a] -> [a]", but the forall quantification is not written out as it
 is implied.
\end_layout

\begin_layout Subsection
Instantiation of types and type inference
\end_layout

\begin_layout Standard
When using a data constructor such as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: ∀a.[a]
\end_layout

\end_inset

, one would want to use it with lists with different element types in different
 locations.
\end_layout

\begin_layout Standard
This is achieved by replacing the bound type variable with new type variables
 wherever it is used.
\end_layout

\begin_layout Standard
If one makes a declaration 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
y = x : []
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset

, one will have:
\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:) :: "a -> [a] -> [a]"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: [b]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x
\end_layout

\end_inset

 is the 1st argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 is the 2nd argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[b] = [a]
\end_layout

\end_inset

, which implies 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = b
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The inferred types are:
\end_layout

\begin_layout Itemize
(:) :: Int -> [Int] -> [Int]
\end_layout

\begin_layout Itemize
[] :: [Int]
\end_layout

\begin_layout Itemize
y :: [Int]
\end_layout

\begin_layout Standard
<TODO: Example using function application/abstraction ?>
\end_layout

\begin_layout Chapter
Introduction to Compilation
\end_layout

\begin_layout Standard
This chapter is intended as an introduction to the general concepts of compilati
on for readers who have little or no experience with the inner workings
 of compilers.
 The approach to compilation described here is not the only one, and only
 describes the compilation steps used in JSHC.
 For a more general and in-depth view of compilers and compilation, 
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

 is recommended.
 
\end_layout

\begin_layout Standard
A compiler is a program that, given program code, produces new code in another
 language, the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
target language
\end_layout

\end_inset

.
 Common examples of compilers' target languages are machine code in the
 case of the GNU C Compiler <TODO: ref>, bytecode to be run in a virtual
 machine in the case of Java <TODO: ref> or another high level programming
 language in the case of the Glasgow Haskell Compiler, which compiles to
 C <TODO: ref>.
 
\end_layout

\begin_layout Standard
A compiler consists of two main parts; the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
front-end
\end_layout

\end_inset

 and the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
back-end
\end_layout

\end_inset

.
 The front-end takes the program code and creates an abstract representation
 of it, and the back-end takes that representation and converts it into
 the target language.
\end_layout

\begin_layout Section
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the first part of the front-end, and is the process
 by which the compiler takes the program code in the form of an input string,
 and parses it into a list of separate tokens, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
lexemes
\end_layout

\end_inset

, which are the smallest significant components in a programming language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book1.2.1"

\end_inset

.
\end_layout

\begin_layout Standard
For example, given a program in a simple language with Haskell-like syntax
 with a source code that looks like this:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fun x y = x + y
\end_layout

\end_inset


\end_layout

\begin_layout Standard
a lexer could generate a list of tokens in this vein:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[fun,x,y,=,x,+,y]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Parsing
\end_layout

\begin_layout Standard
Parsing is the second part of the front-end and takes the list of lexemes
 and interprets it according to a grammar, creating a data structure containing
 an abstract representation of the code, called the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
abstract syntax tree
\end_layout

\end_inset

.
 The abstract syntax tree is a tree (or tree-like) graph with nodes representing
 the application of a certain rule in the grammar.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename adsgadgs.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graphic representation of an AST of a function definition in a simple language
 with Haskell- like syntax.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Semantic analysis
\end_layout

\begin_layout Standard
Semantic analysis gathers various semantic properties of the source program,
 to check for errors and to use later on in the compilation process.
 One common part of semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type checking
\end_layout

\end_inset

, where the compiler searches the abstract syntax tree for type inconsistencies.
 For example, in many languages, adding a boolean to an integer is not a
 valid expression, an error which would be caught by the type checker.
 Another common part of the semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
name checking
\end_layout

\end_inset

, where the compiler checks whether there are any ambiguities in variable
 names used, and whether used variables are in scope where they are used.
\end_layout

\begin_layout Standard
Other operations on the syntax tree, such as reduction of complex constructs
 into simpler, more general constructs can also be done as part of the semantic
 analysis.
 This is done to simplify the code generation process.
 <TODO: not done> 
\end_layout

\begin_layout Section
Code generation
\end_layout

\begin_layout Section
Optimization
\end_layout

\begin_layout Chapter
Method
\end_layout

\begin_layout Standard
The main part of this project is the development of the compiler itself.
 This task is performed by first implementing a working compiler for a small
 subset of Haskell.
 This smaller compiler is then tested and expanded iteratively, until full
 support for the Haskell specification 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 has been achieved.
 <TODO: redo this completely as this is simply not true>
\end_layout

\begin_layout Section
Coding standard
\end_layout

\begin_layout Standard
In 
\end_layout

\begin_layout Section
Tools and libraries used
\end_layout

\begin_layout Standard
Several external tools were used to facilitate the development of JSHC.
 
\end_layout

\begin_layout Subsection
PEG.js
\end_layout

\begin_layout Standard
PEG.js
\begin_inset CommandInset citation
LatexCommand cite
key "peg-js"

\end_inset

 is a JavaScript implementation of parsing expression grammars, which is
 an alternative to context-free grammars and regular expressions for defining
 formal languages
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

.
 The definition of a parsing expression grammar is similar in appearance
 to that of a context-free grammar, with a few key differences.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
unordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
|
\end_layout

\end_inset

 is replaced by an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
ordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
/
\end_layout

\end_inset

.
 This means that, instead of accepting a match on any rule in a production,
 a parsing expression grammar always accepts the first rule matched.
 This means that parsing expression grammars are inherently unambiguous.
 If there are two possible matches to a rule, simply match the one that
 occurred first.
 
\end_layout

\begin_layout Standard
Parsing expression grammars also have several operators similar to those
 used in regular expressions.
 There are the repetition operators 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

 which matches zero or more repetitions of a rule, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 which matches one or more repetitions of a rule.
 There is also the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
?
\end_layout

\end_inset

 operator which eiter matches a rule and returns it, or does not match it
 and returns an empty match.
 Just as with the ordered choice, these operators take a greedy approach,
 i.e.
 they always consume the maximum amount of input possible.
 
\end_layout

\begin_layout Standard
Lastly, parsing expression grammars feature the syntactic predicates 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

.
 These match their paired rule, and either fail or succeed without advancing
 the parser position.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 returns an empty match if the match is successful and fails otherwise,
 while 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

 returns an empty match if the match fails and succeeds otherwise.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
PEG.js generates a Packrat
\begin_inset CommandInset citation
LatexCommand cite
key "ford-packrat"

\end_inset

 parser, i.e.
 a top-down recursive descent parser with backtracking.
 To avoid a worst-case scenario of exponential runtime, packrat parsers
 store intermediate results in a table, sacrificing storage space for guaranteed
 linear-time complexity.
 
\end_layout

\begin_layout Standard
PEG.js was chosen for this project due to the suitability of parsing expression
 grammars for writing lexical analysers 
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

 in a concise and intuitive way, as well as for the efficiency of packrat
 parsers.
 
\end_layout

\begin_layout Subsection
Jison
\end_layout

\begin_layout Standard
Jison is a parser generator for generating JavaScript parsers.
 It takes a context-free grammar in the same format as the input files to
 Bison, apart for parser actions, which are defined in the implementation
 language, which is JavaScript for Jison and C for Bison.
 Just like Bison, the parser generated by Jison is LALR(1) by default
\begin_inset CommandInset citation
LatexCommand cite
key "jison,bison-manual"

\end_inset

, which is the option used for the parser in JSHC.
 
\end_layout

\begin_layout Standard
Jison was chosen mainly because of the familiarity and extensive documentation
 of the Bison notation and functionality, as well as for its powerful constructs
 for handling user-defined error handling, something which is essential
 to a Haskell parser 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report10.3"

\end_inset

.
 The speed and compact size of LALR parsers were also taken into account,
 but not critical for the choice.
 
\end_layout

\begin_layout Subsection
Ymacs
\end_layout

\begin_layout Standard
As a graphical interface to JSHC, a JavaScript-based Emacs-like text editor
 named Ymacs
\begin_inset CommandInset citation
LatexCommand cite
key "ymacs"

\end_inset

 was chosen.
 The main reasons for this choice were that Ymacs is easily extendable and
 is fully compatible with three of the most widely used web browsers (Mozilla
 Firefox, Google Chrome and Apple Safari
\begin_inset CommandInset citation
LatexCommand cite
key "browser-statistics"

\end_inset

).
 Also, Emacs is a popular coding environments among Haskell programmers
\begin_inset CommandInset citation
LatexCommand cite
key "state-of-haskell"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Ymacs interface consists of a window with one or more buffers for entering
 text.
 <TODO: structure of Ymacs>
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
Custom built test suite 
\end_layout

\begin_layout Standard
<TODO: how and what do we test?>
\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard
<TODO: move certain items from here to Theory chapter>
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
Interface
\end_layout

\begin_layout Standard
An interface for using the compiler has been created.
 It uses Ymacs to allow a user to create modules and then load them in an
 interpreter that uses the compiler.
\end_layout

\begin_layout Standard
<TODO: image of the interface with two files and the interpreter open>
\end_layout

\begin_layout Subsection
Ymacs
\end_layout

\begin_layout Standard
Several modifications has been done to the default Ymacs environment.
\end_layout

\begin_layout Subsubsection
Setting modes automatically
\end_layout

\begin_layout Standard
Since no mode is automatically set for new buffers, the creation of a new
 buffer has been modified so that it sets a mode for the buffer based upon
 what the extension of the name of the buffer is.
 This makes it possible to create a new buffer with a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.hs
\end_layout

\end_inset

 extension, and the haskell mode will be set.
\end_layout

\begin_layout Subsubsection
Haskell mode
\end_layout

\begin_layout Standard
A haskell mode for buffers containing haskell code.
 It currently only contains the command 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C-x i
\end_layout

\end_inset

to show the interpreter.
 If the interpreter is visible in a frame, the focus will be changed to
 that buffer, otherwise the current frame is split show it.
 There can only be a single interpreter buffer, so a new interpreter buffer
 is only created if it does not exist.
\end_layout

\begin_layout Subsubsection
Interpreter mode
\end_layout

\begin_layout Standard
To modify an ordinary buffer into a terminal, the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ENTER
\end_layout

\end_inset

 key is a Ymacs command that will read the last line of the buffer send
 the command on the line to the interpreter.
 The 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
TAB
\end_layout

\end_inset

 key is a Ymacs command that sends the command on the last line to the interpret
er, and the buffer is modified depending on if there is none, one, or many
 matches.
\end_layout

\begin_layout Standard
The highlighting for the buffer is coloring lines beginning with 
\begin_inset Quotes eld
\end_inset

Error: 
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

> 
\begin_inset Quotes eld
\end_inset

 to make output easier to read.
\end_layout

\begin_layout Standard
When an interpreter buffer is created, the buffer object itself is modified
 to only allow deletions of characters and selections on the user input
 on the last line, and insertion of text is modified so that text is always
 added at the end of the buffer.
 These changes are achieved by replacing existing functions on the buffer
 with new functions that calls the old ones when appropriate.
\end_layout

\begin_layout Subsection
Interpreter
\end_layout

\begin_layout Standard
The interpreter supports a subset of the GHCi commands, and includes a command
 for evaluation of javascript expressions.
\end_layout

\begin_layout Standard
<TODO: describe currently supported commands>
\end_layout

\begin_layout Section
Dependency groups
\end_layout

\begin_layout Standard
The implementation for handling dependency groups takes a set of entries,
 where each entry provides a set of names, depends on a set of names, and
 contains a set of items, such as modules or declarations.
\end_layout

\begin_layout Standard
These entries will have to be created from the declarations or modules that
 one will want to create dependency groups for.
\end_layout

\begin_layout Standard
The entries are nodes in a graph where the minimal number of entries are
 merged such that there are no longer any cycles in the graph.
\end_layout

\begin_layout Subsection
Condensing the graph
\end_layout

\begin_layout Standard
Given a directed graph representing the dependencies, it merges the minimal
 amount of nodes to create a directed acyclic graph.
 This takes O(|E|+|V|) time.
\end_layout

\begin_layout Standard
<TODO: pseudo code for condensing the graph?>
\end_layout

\begin_layout Standard
<TODO: time and space analysis>
\end_layout

\begin_layout Subsection
Dependency order traversal
\end_layout

\begin_layout Standard
Traversing the graph of the groups in dependency order.
\end_layout

\begin_layout Standard
The algorithm computes the ordering lazily, similar to an iterator, but
 allows for concurrency by producing a set of nodes at each step.
\end_layout

\begin_layout Standard
<TODO: pseudo code here?>
\end_layout

\begin_layout Section
Compiler front-end
\end_layout

\begin_layout Itemize
Find, read and parse all modules: This part identifies the modules used,
 performs lexical analysis on them and parses them into an abstract representati
on of the language, the Abstract Syntax Tree (AST).
 
\end_layout

\begin_layout Itemize
Type checking: This part consists of checking each module for type correctness,
 as well as inferring general types.
 This new inferred type information is added to the AST.
\end_layout

\begin_layout Itemize
Simplification: Before compilation, the AST is simplified, reducing the
 number of different constructs used, to make for easier compilation.
\end_layout

\begin_layout Subsection
Loading modules
\end_layout

\begin_layout Standard
The loading begins with the module names of a set of modules to load, and
 will search for them in a virtual file system (mapping from module names
 to unparsed strings), a list of URLs (which can refer to files using the
 file:// or http:// protocols).
 Each found module must be parsed in order to find out which modules it
 depends upon.
 Those modules (unless already loaded) must then be found and parsed as
 well.
 This process continues until no more modules are needed, and the minimal
 set of modules that satisfies all the module dependencies has been found.
 In case a module can not be found or there is a parse error, this process
 will still continue and try to satisfy more dependencies and see if there
 are more missing modules or parse errors.
\end_layout

\begin_layout Subsubsection
Lexical analysis
\end_layout

\begin_layout Standard
The lexical analysis in JSHC is performed in several steps.
 <TODO: a good way to init this section?>
\end_layout

\begin_layout Standard
While lexical analysis is often done by having the parser request a token
 from the lexical analyser, match that token against a rule, request another
 and so on
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book3.1"

\end_inset

, the layout-dependent syntax of Haskell requires a different approach.
 First, the input (i.e.
 the Haskell source code, including whitespace and comments) is parsed into
 an array of tokens in one go.
 This is done by using a parser built using PEG.js that was fed a translation
 (into PEG.js-readable form) of the lexical program structure described in
 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report2.2"

\end_inset

.
 Second, the generated array of tokens is run through a function that adds
 indentation information to the array in the form of special indentation
 tokens, and annotates tokens with position information.
 Whitespace and comments are discarded as they are no longer needed for
 position information.
 Lastly, this array is fed into an object which interfaces with the parser
 according to the Jison/Bison style API
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book3.1"

\end_inset

, using the indentation information to generate tokens to convert Haskell's
 layout-dependent syntax into a context-free one.
 
\end_layout

\begin_layout Standard
As an example, the code: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f = let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x = 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

y = 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
generates, after the first and second stages this array of tokens (token
 representation rewritten for readability):
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[{1},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

let
\begin_inset Quotes erd
\end_inset

,{3},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,
\begin_inset Quotes erd
\end_inset

in
\begin_inset Quotes erd
\end_inset

,ID,OP,ID]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where the tokens 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{n}
\end_layout

\end_inset

 designate the start of a block after a newline and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
<n>
\end_layout

\end_inset

 representing a newline where a new block should not begin.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
n
\end_layout

\end_inset

 represents the starting column of the first token on the new line.
 Given this array as input, the last stage of the lexer will deliver to
 the parser tokens representing a context-free version of the code which,
 converted back into Haskell source code, would look like this:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{f = let {x = 1;y = 2} in x + y}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parsing
\end_layout

\begin_layout Standard
The context-free syntax is parsed by a parser implemented using the JISON
 parser generator 
\begin_inset CommandInset citation
LatexCommand cite
key "jison"

\end_inset

.
 The parser and the last step of the lexical analysis work in concert, meaning
 that the lexical analyser does not process and return all tokens in one
 go, but only sends the parser tokens when asked to.
 To handle certain features of the layout dependent syntax of Haskell, that
 cannot be handled by the lexical analyser alone, the parser will inform
 the lexical analyser of any such parse errors, so that the lexer can react
 and send new tokens that solve the problem (c.f.
 the description of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
parse-error
\end_layout

\end_inset

 function in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report10.3"

\end_inset

).
 
\end_layout

\begin_layout Standard
<TODO: create figure explaining the layout of finding/lexing/parsing>
\end_layout

\begin_layout Subsection
Checking dependency groups of modules
\end_layout

\begin_layout Standard
The following steps are taken for each group of modules, which are checked
 in dependency order.
\end_layout

\begin_layout Itemize
Export check: Computes the export space of each module
\end_layout

\begin_layout Itemize
Name check: Checks if names are in scope, and qualifies names referring
 to top-level declarations
\end_layout

\begin_layout Itemize
Fixity resolution: Replace all lists of infix applications with operator
 application
\end_layout

\begin_layout Itemize
Type check: Compute types and kinds
\end_layout

\begin_layout Subsubsection
Export check
\end_layout

\begin_layout Standard
The implementation gives an error if modules in the same group have a list
 of exports, as this is currently not supported.
 If the modules do not have a list of exports, all top-level declarations
 are exported, which is easy to handle, and is only what is currently supported.
 If there is only a single module in a group, then the export list may exist
 and the exported names are resolved by looking at all top-level declarations
 and imports.
\end_layout

\begin_layout Subsubsection
Name check
\end_layout

\begin_layout Standard
This is applied separately on each module in a group.
\end_layout

\begin_layout Subsubsection
Fixity Resolution
\begin_inset CommandInset label
LatexCommand label
name "sub:Fixity-Resolution"

\end_inset


\end_layout

\begin_layout Standard
Applied separately on each module in a group.
\end_layout

\begin_layout Standard
Given the available operators and their precedences, adjusts the expressions
 in all function and operator so that they use the declared precedence.
\end_layout

\begin_layout Subsubsection
Type checking
\end_layout

\begin_layout Standard
Checks instance/function top-level declarations in dependency group order.
\end_layout

\begin_layout Standard
It is necessary to use dependency groups and check in dependency group order
 to give the correct type.
 
\end_layout

\begin_layout Standard
<TODO: give a good example or refer to one in the haskell report>
\end_layout

\begin_layout Standard
Checks for missing identifiers (type variables, types, functions, etc..),
 instances, and infer type.
 Adds type information to the AST.
\end_layout

\begin_layout Subsection
Reduction of syntax tree
\end_layout

\begin_layout Standard
This step translates the AST to the intermediate representation used by
 the back-end, see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:B.2Intermediate-representation"

\end_inset

 for details.
 Several constructs are reduced to other, simpler and more general, constructs
 to create a kernel, which is a small subset of Haskell.
 The constructs that can be reduced in this way syntactic sugar of the kernel
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report1.2"

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Conditional expressions
\end_layout

\begin_layout Standard
Conditional expressions are converted into 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

expressions, with two alternatives 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
linebreak
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True -> exp
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
False -> exp
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
This means that the expression: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if x > y then 1 else 0
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as the expression:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case x > y of
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

True -> 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

False -> 2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Let and where expressions
\end_layout

\begin_layout Standard
Since what 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expressions do is bind expressions to local variables, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions have this capability as well, they are converted to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions.
 The right hand sides of the local declarations are inserted into a tuple
 expression, and the left hand sides are put in a tuple pattern.
 The tuple expression is then matched to the tuple pattern inside a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expression, thus causing them to be bound to each other.
\end_layout

\begin_layout Standard
As an example, the expression:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x = 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

y = 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as the expression: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case (1,2) of
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(x,y) -> x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Pattern matching
\end_layout

\begin_layout Standard
Pattern matching in function definitions follows the same rules as in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions, so a simplification is performed here.
 For each alternative match of the function, the arguments are wrapped in
 a tuple pattern and paired with their corresponding right hand side to
 create 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 alternatives.
 Then, the function is given dummy arguments, to preserve its arity.
 A 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expression is then created which matches a tuple expression with the function's
 arguments against the newly created 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 alternatives.
 
\end_layout

\begin_layout Standard
For example, the function: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f True x = x + 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f False x = x - 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as this function:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f a1 a2 = case (a1,a2) of 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(True, x) -> x + 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(False, x) -> x - 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Function declarations
\end_layout

\begin_layout Standard
Function declarations with arguments are converted into a binding from the
 function name to a sequence of lambda expressions corresponding to the
 arity of the function.
\end_layout

\begin_layout Standard
For example, the function:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f x y = x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
is equivalent to and thus results in the same intermediate representation
 as the function:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f = 
\backslash
x -> 
\backslash
y -> x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
List expressions
\end_layout

\begin_layout Standard
List expressions are converted into applications of the list datatype, so
 that the list 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[1,2,3]
\end_layout

\end_inset

 is converted into 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
((:) 1 ((:) 2 ((:) 3 [])))
\end_layout

\end_inset

.
 Note that the cons operator is written in prefix notation, as an ordinary
 data constructor, instead of as an infix constructor, as is normally done
 when writing source code.
 This is because at this stage operator applications have already been removed
 from the language by the fixity resolution algorithm described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Fixity-Resolution"

\end_inset

.
 
\end_layout

\begin_layout Section
Compiler back-end
\end_layout

\begin_layout Standard
Takes an AST in the intermediate representation and translates into the
 target language (JavaScript).
\end_layout

\begin_layout Subsection
Optimization of AST
\end_layout

\begin_layout Standard
Transformations on the AST to optimize the performance in space and time.
 <TODO: strictness analysis, etc..>
\end_layout

\begin_layout Subsection
Code generation
\end_layout

\begin_layout Standard
Generates javascript code representing the compiled modules.
 Compiles a program in the intermediate language to javascript, which can
 then be executed by any javascript interpreter.
\end_layout

\begin_layout Standard
Can be compiled so that all exported identifiers would use the same name
 in javascript (under some namespace), which allows easy lookup of identifiers
 by an interpreter, but also debugging of the compiler.
\end_layout

\begin_layout Subsection
Interpretation
\end_layout

\begin_layout Standard
Interpret the AST by re-writing the AST while producing the required side-effect
s.
\end_layout

\begin_layout Section
Standard libraries
\end_layout

\begin_layout Standard
<TODO: describe how the code from the Haskell report was used to construct
 the standard libraries for the compiler>
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "jshc"
options "plain"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Nomenclature
\end_layout

\begin_layout Chapter
Syntax reference
\end_layout

\begin_layout Standard
Detailed in this appendix is a reference to the subset of the Haskell syntax
 supported by JSHC, as well as the intermediate representation used by the
 code generation.
 
\end_layout

\begin_layout Section
Context-free syntax
\end_layout

\begin_layout Standard
The same notational convention used in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 is used here, i.e:
\end_layout

\begin_layout Standard
[pattern] : optional
\end_layout

\begin_layout Standard
{pattern} : zero or more repetitions
\end_layout

\begin_layout Standard
(pattern) : grouping
\end_layout

\begin_layout Standard
pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 | pat
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
nonterm -> alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 | alt
\begin_inset Formula $_{\text{2}}$
\end_inset

 | … | alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 : production
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module → module modid [exports] where body 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| body
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body → { impdecls ; topdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { impdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { topdecls }
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecls → impdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; impdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exports → ( export
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , export
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
export → qvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycon [(..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycls [(..) | ( qvar
\begin_inset Formula $_{\text{1}}$
\end_inset

, … , qvar
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| module modid
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecl → import modid [impspec]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (empty declaration)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impspec → ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| hiding ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tycon [ (..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

)] (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
cname → var | con
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls → topdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; topdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl → type simpletype = type
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| data simpletype [= constrs]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| decl
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decls → { decl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; decl
\begin_inset Formula $_{\text{n}}$
\end_inset

 } (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl → gendecl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (funlhs | pat) rhs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gendecl → vars :: type (type signature)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fixity [integer] ops (fixity declaration)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (empty declaration)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ops → op
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , op
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
vars → var
\begin_inset Formula $_{\text{1}}$
\end_inset

 , …, var
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fixity → infixl | infixr | infix
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
type → btype [-> type] (function type)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
btype → [btype] atype (type application)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
atype → gtycon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tyvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , type
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) (tuple type, k ≥ 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ type ] (list type)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type ) (parenthesized constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gtycon → qtycon
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
simpletype → tycon tyvar
\begin_inset Formula $_{\text{1}}$
\end_inset

 … tyvar
\begin_inset Formula $_{\text{k}}$
\end_inset

 (k ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constrs → constr
\begin_inset Formula $_{\text{1}}$
\end_inset

 | … | constr
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constr → con [!] atype
\begin_inset Formula $_{\text{1}}$
\end_inset

 … [!] atype
\begin_inset Formula $_{\text{k}}$
\end_inset

 (arity con = k, k ≥ 0)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
funlhs → var apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| pat varop pat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( funlhs ) apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
rhs → = exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp → infixexp :: type (expression type signature)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| infixexp 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
infixexp → lexp qop infixexp (infix operator application)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| - infixexp (prefix negation)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| lexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lexp → 
\backslash
 apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{n}}$
\end_inset

 -> exp (lambda abstraction, n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| let decls in exp (let expression)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| if exp [;] then exp [;] else exp (conditional)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| case exp of { alts } (case expression)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fexp → [fexp] aexp (function application)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
aexp → qvar (variable)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon (general constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp ) (parenthesized expression)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) (tuple, k ≥ 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ] (list, k ≥ 1)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts → alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt → pat -> exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat → lpat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lpat → apat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{k}}$
\end_inset

 (arity gcon = k, k ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
apat → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon (arity gcon = 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| _ (wildcard)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat ) (parenthesized pattern)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , pat
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) (tuple pattern, k ≥ 2)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
var → varid | ( varsym ) (variable)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvar → qvarid | ( qvarsym ) (qualified variable)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
con → conid | ( consym ) (constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qcon → qconid | ( gconsym ) (qualified constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varop → varsym | ` varid ` (variable operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvarop → qvarsym | ` qvarid ` (qualified variable operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
conop → consym | ` conid ` (constructor operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qconop → gconsym | ` qconid ` (qualified constructor operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
op → varop | conop (operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qop → qvarop | qconop (qualified operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gconsym → : | qconsym 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Intermediate representation
\begin_inset CommandInset label
LatexCommand label
name "sec:B.2Intermediate-representation"

\end_inset


\end_layout

\begin_layout Standard
For detailing the intermediate representation, these notational conventions
 are used:
\end_layout

\begin_layout Standard
node → { item
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , item
\begin_inset Formula $_{\text{n}}$
\end_inset

}
\end_layout

\begin_layout Standard
item → name: value | [name: value]
\end_layout

\begin_layout Standard
rule
\begin_inset Formula $_{\text{1}}$
\end_inset

 | rule
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
name : the name of a n item inside a node
\end_layout

\begin_layout Standard
value : the value of an item inside a node, values can be both terminals
 and nonterminals
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module -> {name: "module",modid: <modname>, body: <body>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body -> {name: "body", topdecls: <topdecls>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls -> <topdecl>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <topdecl>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl -> {name: "topdecl-decl", decl: <decl>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl -> {name: "decl-fun", ident: <varname>, rhs: exp}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exps -> <exp>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <exp>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp -> {name: "lambda", args: <args>, rhs: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "case", exp: <exp>, alts: <alts>}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "application", exps: <exps>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple", members: <exps>}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
At this stage, it is legal for a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple-pat
\end_layout

\end_inset

 to have 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
members.length == 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "negate", exp: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts -> <alt>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <alt>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt -> {name: "alt", pat <pat> exp: <exp>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pats -> <pat>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <pat>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat -> {name: "conpat", con: dacon, pats: <pats>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple-pat", members: <pats>} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{1}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "wildcard"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
modname -> {name: "modname", id: dacon}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon -> {name: "dacon", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
loc
\end_layout

\end_inset

 is used to determine whether a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname
\end_layout

\end_inset

 is qualified, and what that qualification is.
 At this stage, anything that is not qualified is a local variable.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname -> {name: "varname", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{2}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
literal -> {name: "integer-lit", val: <STRING>} 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
STRING -> a javascript String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
NUMBER -> a javascript Number
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<TODO: some significant pieces of the source code, test cases, etc..
 probably an example of how the compiler can be used on a web page>
\end_layout

\end_body
\end_document
