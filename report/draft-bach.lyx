#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
\myTOC
\clearpage
\pagenumbering{arabic}
}
\end_preamble
\use_default_options true
\begin_modules
logicalmkup
\end_modules
\language english
\inputencoding auto
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Modern web applications are becoming more and more complex, with users expecting
 more and more automation of menial tasks such as spelling correction and
 autocompletion of text.
 This leads to web applications becoming larger and more complex, which
 in turn means that they are becoming more error prone<TODO: reference?>.
 One large source of errors in web applications is the absence of type safety
 in the form of static type checking in most scripting languages aimed at
 web development, such as JavaScript or PHP <TODO: reference? A Type System
 for Dynamic Web Documents has some stuff, then the Curry stuff can be useful>.
 One solution to this problem is providing an extra layer of abstraction
 on top of these scripts, that in turn can be subject to static type checking.
 For example another, already existing, programming language that has these
 features can be used.
 
\end_layout

\begin_layout Standard
Haskell is one such language, designed with type-safety as one of the major
 concerns <TODO:ref: ?>.
 By compiling Haskell directly to JavaScript, we use its strong type system
 to guard against some of the errors that are hard to avoid when writing
 large and complex application with a dynamically typed language such as
 JavaScript.
 <TODO: better formulation plox> 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Using Haskell for web-programming is not a new concept; there are several
 projects out there with a similar approach to the one presented here.
 Notable ones are Yesod 
\begin_inset CommandInset citation
LatexCommand cite
key "yesod-book"

\end_inset

, which is a full-featured web server framework, and YCR2JS 
\begin_inset CommandInset citation
LatexCommand cite
key "yhc-js"

\end_inset

, a JavaScript back end to the York Haskell Compiler.
 <TODO: elaborate here>
\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
The purpose of this thesis is to present an implementation of a fully JavaScript
 Haskell-compiler (i.e.
 a compiler written entirely in JavaScript, compiling Haskell to JavaScript).
 Coupled with the compiler will be an interface in the form of a JavaScript-base
d text editor with an interactive code console (in the vein of the Glasgow
 Haskell Compiler's GHCi).
 By writing the compiler entirely in JavaScript, all computations will be
 performed by the client, thus greatly lightening the server load compared
 to having the computations run server-side, while still saving the user
 the work of downloading a compiler to their computer.
 The compiler supports the entirety of Haskell, as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

.<TODO: Extensions?>
\end_layout

\begin_layout Chapter
Introduction to Haskell
\end_layout

\begin_layout Standard
This chapter is intended as a quick but thorough introduction to Haskell
 for readers unfamiliar with or new to Haskell and/or functional languages.
 It consists of a very general overview, followed by separate sub chapters
 with details about specific features.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Haskell is a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
lazy
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
purely functional
\end_layout

\end_inset

 programming language with 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
strong static typing
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
type inference
\end_layout

\end_inset

.
 A program in Haskell consists of one or more modules, interconnected by
 their import and export specifications.
 The contents of a module is a set of top-level declarations, which can
 be, among others, function declarations, datatype declarations and typeclass
 declarations.
 Functions consist of a name, a set of arguments and an expression, that
 expresses the result of the function when applied to its arguments.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being lazy means that an expression is only evaluated when its result is
 needed.
 Any expression whose result is not used is simply ignored.
 This enables lazy languages to feature some things that are otherwise impossibl
e, such as infinite data structures.
 Since the data structure is lazy, only the part that is needed.
 For example, a list of infinite length can be described in Haskell using
 like so:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x = [1..]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This statement assigns to the variable x an expression that calculates an
 infinite list containing all integers > 0 in rising order.
 While an expression calculating this in a strict language would never terminate
 as the set of integers > 0 is infinite, a lazy language only calculates
 the needed parts, e.g:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
take 5 x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where take is a function that returns a list consisting of the first n elements
 in a list, only needs the first 5 elements of x, so no more than 5 elements
 are computed.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being purely functional, Haskell's functions do not have side effects.
 <TODO: more on purity>
\end_layout

\begin_layout Standard
Another feature of purely functional languages is that functions are first-class
 objects.
 This means that functions can be passed around as arguments to other functions,
 be returned as the result of a function or created at runtime.
 This enables the creation of 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
higher order functions
\end_layout

\end_inset

, generalized functions that use other functions as arguments.
 For example, the function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
filter
\end_layout

\end_inset

 from the Haskell standard libraries takes a function, which takes one argument
 and returns a boolean, and a list.
 The function then applies the supplied function to each element in the
 list and returns a new list with all elements for which the supplied function
 returned 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<TODO: type system>
\end_layout

\begin_layout Standard
Haskell’s module system is its main method of encapsulation.
 Apart from local variables in a certain function, it is the only way to
 determine whether something is known (i.e.
 in scope) or not.
 Each module has a name, a set of imports and a set of exports.
 The specification of these is optional, with defaults being “Main”, the
 empty import set and the export set containing all top-level declarations,
 respectively.
 
\end_layout

\begin_layout Section
Module system <TODO; need not be this much>
\end_layout

\begin_layout Standard
Haskell’s module system main method of encapsulation.
 Apart from local variables in a certain function, it is the only way to
 determine whether something is known (i.e.
 in scope) or not.
 Each module has a name, a set of imports and a set of exports.
 The specification of these is optional, with defaults being “Main”, the
 empty import set and the export set containing all top-level declarations,
 respectively.
 
\end_layout

\begin_layout Standard
Specification of module name and exports is done by the clause 
\end_layout

\begin_layout Standard

\family typewriter
module Name [(export
\begin_inset Formula $_{\text{}}$
\end_inset


\begin_inset Formula $1$
\end_inset

,..
 export
\begin_inset Formula $_{\text{}}$
\end_inset


\begin_inset Formula $n$
\end_inset

)] where 
\end_layout

\begin_layout Standard
where 
\family typewriter
Name
\family default
 is any number of identifiers starting with an uppercase letter, separated
 by points.
 The export specification, within square brackets, is optional and contains
 elements of the form 
\end_layout

\begin_layout Standard

\family typewriter
(f, module M, T) 
\end_layout

\begin_layout Standard
where 
\family typewriter
f
\family default
 is the name of a function, 
\family typewriter
M
\family default
 is the name of a module and 
\family typewriter
T
\family default
 is the name of an abstract datatype or typeclass.
 In English, the first item would mean “export the function known to this
 module with the name 
\family typewriter
f
\family default
”, the second item “export everything imported from the module 
\family typewriter
M
\family default
” and the third item “export the abstract datatype or typeclass known to
 this module with the name 
\family typewriter
T
\family default
”.
 Note that the third item only exports the name of the datatype or typeclass,
 not their respective members.
 This means that if we export a type 
\family typewriter
T
\family default
 with the definition
\end_layout

\begin_layout Standard

\family typewriter
data T = U | V 
\end_layout

\begin_layout Standard
without specifying its exports, the importing modules will not be able to
 access the constructors 
\family typewriter
U
\family default
 and 
\family typewriter
V
\family default
, only the type itself: 
\family typewriter
T
\family default
.
 This means that an importing module can write functions that take arguments
 or return values of type 
\family typewriter
T
\family default
, but not directly access its values (e.g.
 pattern matching).
 For importing modules to be able to access members of a datatype or typeclass,
 the exporting module can specify this in its export list like so: 
\end_layout

\begin_layout Standard

\family typewriter
(T(..), A(B,c)) 
\end_layout

\begin_layout Standard
where 
\family typewriter
T, A
\family default
 are abstract datatypes or typeclasses.
 In English, the first item would mean “export the abstract datatype or
 typeclass known to this module with the name 
\family typewriter
T
\family default
, as well as all of its members” and the second “export the abstract datatype
 or typeclass known to this module with the name 
\family typewriter
T
\family default
, as well as those of its members with the names 
\family typewriter
B
\family default
 and 
\family typewriter
c
\family default
”.
 
\end_layout

\begin_layout Standard
Import specification is done by clauses such as 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import A 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import B (f,g) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
import C hiding (f,g) 
\end_layout

\begin_layout Standard
where 
\family typewriter
A,B,C
\family default
 are module names.
 In English, the first line would mean “import from 
\family typewriter
A
\family default
 everything that it exports”, the second line “import from 
\family typewriter
B
\family default
 only the exports 
\family typewriter
f
\family default
 and 
\family typewriter
g
\family default
” and the third line “import from 
\family typewriter
C
\family default
 everything that it exports, except 
\family typewriter
f
\family default
 and 
\family typewriter
g
\family default
”.
 
\end_layout

\begin_layout Standard
<TODO: put relevant theory here, to unclutter other chapters>
\end_layout

\begin_layout Section
Dependency groups
\end_layout

\begin_layout Standard
Since modules can mutually depend on each other, there can be a cycle in
 the dependencies between modules.
\end_layout

\begin_layout Standard
If a module A and a module B depends on each other by importing functions
 from the other module, one can not analyse one before the other, as the
 imported functions will be missing.
\end_layout

\begin_layout Standard
To solve this, one must analyse A and B together.
\end_layout

\begin_layout Standard
More generally, one creates a dependency group for any set of modules that
 creates a dependency cycle such as A depends on B, B depends on C, and
 C depends on A.
\end_layout

\begin_layout Standard
The dependency groups are the strongly connected components in the directed
 graph of dependencies between single modules.
\end_layout

\begin_layout Standard
After they have been computed, the resulting graph is a DAG (directed acyclic
 graph) where nodes are dependency groups, and the edges are the dependencies
 between the groups.
\end_layout

\begin_layout Standard
As there are no cycles in the dependencies between the groups, it is possible
 to traverse the groups in dependency order (a reverse topological ordering).
\end_layout

\begin_layout Standard
The Haskell standard 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 mentions dependency groups in Chapters 4.5.1, 4.5.2, and 4.6, related to different
 topics.
\end_layout

\begin_layout Standard
This concept is used in two places of the compiler.
 It is needed to describe sets of modules that depend on each other, sets
 of top-level declarations that depend on each other (even between different
 modules), and declarations in let/where expressions.
\end_layout

\begin_layout Standard
<TODO: perhaps an image of a few modules as an example.
 A->B->A, C->D->E->C, C->B, F->E, D->G.>
\end_layout

\begin_layout Chapter
Introduction to Compilation
\end_layout

\begin_layout Standard
This chapter is intended as an introduction to the general concepts of compilati
on for readers who have little or no experience with the inner workings
 of compilers.
 The approach to compilation described here is not the only one, and only
 describes the compilation steps used in JSHC.
 For a more general and in-depth view of compilers and compilation, 
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

 is recommended.
 
\end_layout

\begin_layout Standard
A compiler is a program that, given program code, produces new code in another
 language, the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
target language
\end_layout

\end_inset

.
 Common examples of compilers' target languages are machine code in the
 case of the GNU C Compiler <TODO: ref>, bytecode to be run in a virtual
 machine in the case of Java <TODO: ref> or another high level programming
 language in the case of the Glasgow Haskell Compiler, which compiles to
 C <TODO: ref>.
 
\end_layout

\begin_layout Standard
A compiler consists of two main parts; the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
front-end
\end_layout

\end_inset

 and the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
back-end
\end_layout

\end_inset

.
 The front-end takes the program code and creates an abstract representation
 of it, and the back-end takes that representation and converts it into
 the target language.
\end_layout

\begin_layout Section
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the first part of the front-end, and is the process
 by which the compiler takes the program code in the form of an input string,
 and parses it into a list of separate tokens, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
lexemes
\end_layout

\end_inset

, which are the smallest significant components in a programming language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book1.2.1"

\end_inset

.
\end_layout

\begin_layout Standard
For example, given a program in a simple language with Haskell-like syntax
 with a source code that looks like this:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fun x y = x + y
\end_layout

\end_inset


\end_layout

\begin_layout Standard
a lexer could generate a list of tokens in this vein:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[fun,x,y,=,x,+,y]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Parsing
\end_layout

\begin_layout Standard
Parsing is the second part of the front-end and takes the list of lexemes
 and interprets it according to a grammar, creating a data structure containing
 an abstract representation of the code, called the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
abstract syntax tree
\end_layout

\end_inset

.
 The abstract syntax tree is a tree (or tree-like) graph with nodes representing
 the application of a certain rule in the grammar.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename adsgadgs.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graphic representation of an AST of a function definition in a simple language
 with Haskell- like syntax.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Semantic analysis
\end_layout

\begin_layout Standard
Semantic analysis gathers various semantic properties of the source program,
 to check for errors and to use later on in the compilation process.
 One common part of semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type checking
\end_layout

\end_inset

, where the compiler searches the abstract syntax tree for type inconsistencies.
 For example, in many languages, adding a boolean to an integer is not a
 valid expression, an error which would be caught by the type checker.
 Another common part of the semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
name checking
\end_layout

\end_inset

, where the compiler checks whether there are any ambiguities in variable
 names used, and whether used variables are in scope where they are used.
\end_layout

\begin_layout Standard
Other operations on the syntax tree, such as reduction of complex constructs
 into simpler, more general constructs can also be done as part of the semantic
 analysis.
 This is done to simplify the code generation process.
 <TODO: not done> 
\end_layout

\begin_layout Section
Code generation
\end_layout

\begin_layout Section
Optimization
\end_layout

\begin_layout Chapter
Method
\end_layout

\begin_layout Standard
The main part of this project is the development of the compiler itself.
 This task is performed by first implementing a working compiler for a small
 subset of Haskell.
 This smaller compiler is then tested and expanded iteratively, until full
 support for the Haskell specification 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 has been achieved.
 <TODO: redo this completely as this is simply not true>
\end_layout

\begin_layout Section
Coding standard
\end_layout

\begin_layout Standard
In 
\end_layout

\begin_layout Section
Tools and libraries used
\end_layout

\begin_layout Standard
Several external tools were used to facilitate the development of JSHC.
 
\end_layout

\begin_layout Subsection
PEG.js
\end_layout

\begin_layout Standard
PEG.js
\begin_inset CommandInset citation
LatexCommand cite
key "peg-js"

\end_inset

 is a JavaScript implementation of parsing expression grammars, which is
 a alternative to context free grammars and regular expressions for defining
 formal languages
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

.
 The definition of a parsing expression grammar is similar in appearance
 to that of a context-free grammar, with a few key differences.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
unordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
'|'
\end_layout

\end_inset

 is replaced by an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
ordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
'/'
\end_layout

\end_inset

.
 This means that, instead of reducing when matching any rule in a production,
 a parsing expression grammar always reduces on the first rule matched.
 This means that parsing expression grammars are inherently unambiguous.
 If there are two possible matches to a rule, simply match the one that
 occurred first.
 
\end_layout

\begin_layout Standard
Parsing expression grammars also have several operators similar to those
 used in regular expressions.
 There are the repetition operators 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
'*'
\end_layout

\end_inset

 which matches zero or more repetitions of a rule, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
'+'
\end_layout

\end_inset

 which matches one or more repetitions of a rule.
 There is also the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
'?'
\end_layout

\end_inset

 operator which eiter matches a rule and returns it, or does not match it
 and returns an empty match.
 Just as with the ordered choice, these operators take a greedy approach,
 i.e.
 they always consume the maximum amount of input possible.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Itemize
Unordered vs ordered choice
\end_layout

\begin_layout Itemize
repetition operators ? + *
\end_layout

\begin_layout Itemize
logical predicates & and !
\end_layout

\begin_layout Subsection
Jison
\end_layout

\begin_layout Standard
PEG.js, Jison, Ymacs
\end_layout

\begin_layout Standard
<TODO: describe the tools and libraries used, hows and whys>
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
Custom built test suite 
\end_layout

\begin_layout Standard
<TODO: how and what do we test?>
\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard
<TODO: move certain items from here to Theory chapter>
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Itemize
Find, read and parse all modules: This part identifies the modules used,
 performs lexical analysis on them and parses them into an abstract representati
on of the language, the Abstract Syntax Tree (AST).
 
\end_layout

\begin_layout Itemize
Type checking: This part consists of checking each module for type correctness,
 as well as inferring general types.
 This new inferred type information is added to the AST.
\end_layout

\begin_layout Itemize
Simplification: Before compilation, the AST is simplified, reducing the
 number of different constructs used, to make for easier compilation.
\end_layout

\begin_layout Itemize
Translation to target: The simplified AST is translated into the target
 language (JavaScript).
\end_layout

\begin_layout Section
Interface
\end_layout

\begin_layout Subsection
Ymacs
\end_layout

\begin_layout Standard
<TODO: describe the changes to the standard Ymacs environment>
\end_layout

\begin_layout Subsection
Interpreter
\end_layout

\begin_layout Standard
The interpreter supports a subset of the GHCi commands, and includes a command
 for evaluation of javascript expressions.
\end_layout

\begin_layout Standard
<TODO: describe currently supported commands>
\end_layout

\begin_layout Section
Dependency groups
\end_layout

\begin_layout Standard
The implementation for handling dependency groups takes a set of entries,
 where each entry provides a set of names, depends on a set of names, and
 contains a set of items, such as modules or declarations.
\end_layout

\begin_layout Standard
These entries will have to be created from the declarations or modules that
 one will want to create dependency groups for.
\end_layout

\begin_layout Standard
The entries are nodes in a graph where the minimal number of entries are
 merged such that there are no longer any cycles in the graph.
\end_layout

\begin_layout Subsection
Condensing the graph
\end_layout

\begin_layout Standard
Given a directed graph representing the dependencies, it merges the minimal
 amount of nodes to create a directed acyclic graph.
 This takes O(|E|+|V|) time.
\end_layout

\begin_layout Standard
<TODO: pseudo code for condensing the graph?>
\end_layout

\begin_layout Standard
<TODO: time and space analysis>
\end_layout

\begin_layout Subsection
Dependency order traversal
\end_layout

\begin_layout Standard
Traversing the graph of the groups in dependency order.
\end_layout

\begin_layout Standard
The algorithm computes the ordering lazily, similar to an iterator, but
 allows for concurrency by producing a set of nodes at each step.
\end_layout

\begin_layout Standard
<TODO: pseudo code here?>
\end_layout

\begin_layout Section
Compiler front-end
\end_layout

\begin_layout Subsection
Loading modules
\end_layout

\begin_layout Standard
The loading process will be given a set of module names to load, and will
 search for them in a virtual file system (mapping from module names to
 unparsed strings), a list of URLs (which can refer to files using the file://
 or http:// protocols).
 Each found module must be parsed in order to find what it depends upon.
 The imported modules must then be found and parsed as well.
 This process continues until no more modules are needed, and the minimal
 set of modules that satisfies all the module dependencies has been found.
 In case a module can not be found or there is a parse error, the process
 will continue and try to satisfy more dependencies and see if there are
 more missing modules or parse errors.
\end_layout

\begin_layout Subsection
Lexical analysis
\end_layout

\begin_layout Standard
The lexical analysis in JSHC is performed in several steps.
 First, the input (i.e.
 the Haskell source code) is parsed into tokens.
 This is done by using a parser built using a JavaScript implementation
 of Parsing Expression Grammar 
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

, PEG.js 
\begin_inset CommandInset citation
LatexCommand cite
key "peg-js"

\end_inset

 that was fed a translation (into PEG.js-readable form) of the lexical program
 structure described in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report2.2"

\end_inset

.
 The generated list of tokens is then run through a custom-built set of
 functions, designed to calculate and annotate the tokens with position
 information (i.e.
 location in the source code), remove whitespace (i.e.
 characters that only serve to define the position of, and separate, other
 characters, such as spaces, tabs, newlines or comments), and annotate the
 token list with indentation and context information for use in the final
 pass of the lexical analysis.
 This last pass is where the layout-dependent syntax of Haskell 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report10.3"

\end_inset

, is converted into a context-free syntax, which is required for the parsing
 step.
 
\end_layout

\begin_layout Subsection
Parsing
\end_layout

\begin_layout Standard
The context-free syntax is parsed by a parser implemented using the JISON
 parser generator 
\begin_inset CommandInset citation
LatexCommand cite
key "jison"

\end_inset

<TODO: more about the parser, JISON> The parser and the last step of the
 lexical analysis work in concert, meaning that the lexical analyser does
 not process and return all tokens in one go, but only sends the parser
 tokens when asked to.
 To handle certain features of the layout dependent syntax of Haskell, that
 cannot be handled by the lexical analyser alone, the parser will inform
 the lexical analyser of any such parse errors, so that the lexer can react
 and send new tokens that solve the problem (c.f.
 the description of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
parse-error
\end_layout

\end_inset

 function in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report10.3"

\end_inset

).
 
\end_layout

\begin_layout Standard
<TODO: create figure explaining the layout of finding/lexing/parsing>
\end_layout

\begin_layout Subsection
Checking modules
\end_layout

\begin_layout Standard
The module dependency groups are checked in dependency order.
 It is necessary to be done in dependency order as the imports are needed
 to know the complete set of available identifiers (and the type/kind) and
 fixity declarations of operators.
\end_layout

\begin_layout Standard
<TODO: include pseudo-code to describe the steps using the algorithms described
 below>
\end_layout

\begin_layout Subsubsection
Adjusting expressions using operators
\end_layout

\begin_layout Standard
Given the available operators and their precedences, adjusts the expressions
 in all function/operator/instance declarations so that they use the declared
 precedence.
\end_layout

\begin_layout Subsubsection
Kind checking
\end_layout

\begin_layout Standard
Checks type/data/newtype/class top-level declarations in dependency group
 order.
\end_layout

\begin_layout Standard
It is necessary to use dependency groups and check in dependency group order
 to give the correct kind.
 
\end_layout

\begin_layout Standard
<TODO: give a good example or refer to one in the haskell report>
\end_layout

\begin_layout Standard
Checks for missing identifiers (type variables, types), infer kind.
\end_layout

\begin_layout Subsubsection
Type checking
\end_layout

\begin_layout Standard
Checks instance/function top-level declarations in dependency group order.
\end_layout

\begin_layout Standard
It is necessary to use dependency groups and check in dependency group order
 to give the correct type.
 
\end_layout

\begin_layout Standard
<TODO: give a good example or refer to one in the haskell report>
\end_layout

\begin_layout Standard
Checks for missing identifiers (type variables, types, functions, etc..),
 instances, and infer type.
 Adds type information to the AST.
\end_layout

\begin_layout Subsection
Reduction of syntax tree
\end_layout

\begin_layout Standard
Removes some constructs from the AST.
\end_layout

\begin_layout Standard
The following constructs disappear as they are translated into other constructs:
 Pattern matching, Operator application, Section, Conditional, Syntactic
 sugar for lists, Arithmetic Sequences, List Comprehensions,Let Expressions,
 Do Expressions, Record construction, Record update.
\end_layout

\begin_layout Standard
<TODO: make a nice table containing translations from one sentential form
 to another similar to the report>
\end_layout

\begin_layout Section
Compiler back-end
\end_layout

\begin_layout Standard
Is given an AST using the intermediate representation.
\end_layout

\begin_layout Subsection
Optimization of AST
\end_layout

\begin_layout Standard
Transformations on the AST to optimize the performance in space and time.
 <TODO: strictness analysis, etc..>
\end_layout

\begin_layout Subsection
Code generation
\end_layout

\begin_layout Standard
Generates javascript code representing the compiled modules.
 Compiles a program in the intermediate language to javascript, which can
 then be executed by any javascript interpreter.
\end_layout

\begin_layout Standard
Can be compiled so that all exported identifiers would use the same name
 in javascript (under some namespace), which allows easy lookup of identifiers
 by an interpreter, but also debugging of the compiler.
\end_layout

\begin_layout Subsection
Interpretation
\end_layout

\begin_layout Standard
Interpret the AST by re-writing the AST while producing the required side-effect
s.
\end_layout

\begin_layout Section
Standard libraries
\end_layout

\begin_layout Standard
<TODO: describe how the code from the Haskell report was used to construct
 the standard libraries for the compiler>
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "jshc"
options "plain"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Nomenclature
\end_layout

\begin_layout Chapter
Syntax reference
\end_layout

\begin_layout Standard
Detailed in this appendix is a reference to the subset of the Haskell syntax
 supported by JSHC, as well as the intermediate representation used by the
 code generation.
 
\end_layout

\begin_layout Section
Context-free syntax
\end_layout

\begin_layout Standard
The same notational convention used in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 is used here, i.e:
\end_layout

\begin_layout Standard
[pattern] : optional
\end_layout

\begin_layout Standard
{pattern} : zero or more repetitions
\end_layout

\begin_layout Standard
(pattern) : grouping
\end_layout

\begin_layout Standard
pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 | pat
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
nonterm -> alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 | alt
\begin_inset Formula $_{\text{2}}$
\end_inset

 | … | alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 : production
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module → module modid [exports] where body 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| body
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body → { impdecls ; topdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { impdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { topdecls }
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecls → impdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; impdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exports → ( export
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , export
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
export → qvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycon [(..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycls [(..) | ( qvar
\begin_inset Formula $_{\text{1}}$
\end_inset

, … , qvar
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| module modid
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecl → import modid [impspec]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (empty declaration)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impspec → ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| hiding ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tycon [ (..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

)] (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
cname → var | con
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls → topdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; topdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl → type simpletype = type
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| data simpletype [= constrs]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| decl
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decls → { decl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; decl
\begin_inset Formula $_{\text{n}}$
\end_inset

 } (n ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl → gendecl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (funlhs | pat) rhs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gendecl → vars :: type (type signature)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fixity [integer] ops (fixity declaration)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (empty declaration)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ops → op
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , op
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
vars → var
\begin_inset Formula $_{\text{1}}$
\end_inset

 , …, var
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fixity → infixl | infixr | infix
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
type → btype [-> type] (function type)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
btype → [btype] atype (type application)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
atype → gtycon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tyvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , type
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) (tuple type, k ≥ 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ type ] (list type)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type ) (parenthesized constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gtycon → qtycon
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
simpletype → tycon tyvar
\begin_inset Formula $_{\text{1}}$
\end_inset

 … tyvar
\begin_inset Formula $_{\text{k}}$
\end_inset

 (k ≥ 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constrs → constr
\begin_inset Formula $_{\text{1}}$
\end_inset

 | … | constr
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constr → con [!] atype
\begin_inset Formula $_{\text{1}}$
\end_inset

 … [!] atype
\begin_inset Formula $_{\text{k}}$
\end_inset

 (arity con = k, k ≥ 0)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
funlhs → var apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| pat varop pat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( funlhs ) apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
rhs → = exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp → infixexp :: type (expression type signature)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| infixexp 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
infixexp → lexp qop infixexp (infix operator application)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| - infixexp (prefix negation)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| lexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lexp → 
\backslash
 apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{n}}$
\end_inset

 -> exp (lambda abstraction, n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| let decls in exp (let expression)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| if exp [;] then exp [;] else exp (conditional)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| case exp of { alts } (case expression)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fexp → [fexp] aexp (function application)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
aexp → qvar (variable)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon (general constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp ) (parenthesized expression)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) (tuple, k ≥ 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ] (list, k ≥ 1)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts → alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 (n ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt → pat -> exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat → lpat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lpat → apat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{k}}$
\end_inset

 (arity gcon = k, k ≥ 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
apat → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon (arity gcon = 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| _ (wildcard)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat ) (parenthesized pattern)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , pat
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) (tuple pattern, k ≥ 2)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
var → varid | ( varsym ) (variable)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvar → qvarid | ( qvarsym ) (qualified variable)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
con → conid | ( consym ) (constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qcon → qconid | ( gconsym ) (qualified constructor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varop → varsym | ` varid ` (variable operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvarop → qvarsym | ` qvarid ` (qualified variable operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
conop → consym | ` conid ` (constructor operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qconop → gconsym | ` qconid ` (qualified constructor operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
op → varop | conop (operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qop → qvarop | qconop (qualified operator)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gconsym → : | qconsym 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Intermediate representation
\end_layout

\begin_layout Standard
For detailing the intermediate representation, these notational conventions
 are used:
\end_layout

\begin_layout Standard
node → { item
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , item
\begin_inset Formula $_{\text{n}}$
\end_inset

}
\end_layout

\begin_layout Standard
item → name: value | [name: value]
\end_layout

\begin_layout Standard
rule
\begin_inset Formula $_{\text{1}}$
\end_inset

 | rule
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
name : the name of a n item inside a node
\end_layout

\begin_layout Standard
value : the value of an item inside a node, values can be both terminals
 and nonterminals
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module -> {name: "module",modid: <modname>, body: <body>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body -> {name: "body", topdecls: <topdecls>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls -> <topdecl>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <topdecl>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl -> {name: "topdecl-decl", decl: <decl>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl -> {name: "decl-fun", ident: <varname>, rhs: exp}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exps -> <exp>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <exp>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp -> {name: "lambda", args: <args>, rhs: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "case", exp: <exp>, alts: <alts>}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "application", exps: <exps>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple", members: <exps>}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
At this stage, it is legal for a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple-pat
\end_layout

\end_inset

 to have 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
members.length == 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "negate", exp: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts -> <alt>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <alt>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt -> {name: "alt", pat <pat> exp: <exp>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pats -> <pat>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <pat>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat -> {name: "conpat", con: dacon, pats: <pats>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple-pat", members: <pats>} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{1}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "wildcard"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
modname -> {name: "modname", id: dacon}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon -> {name: "dacon", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
loc
\end_layout

\end_inset

 is used to determine whether a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname
\end_layout

\end_inset

 is qualified, and what that qualification is.
 At this stage, anything that is not qualified is a local variable.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname -> {name: "varname", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{2}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
literal -> {name: "integer-lit", val: <STRING>} 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
STRING -> a javascript String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
NUMBER -> a javascript Number
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<TODO: some significant pieces of the source code, test cases, etc..
 probably an example of how the compiler can be used on a web page>
\end_layout

\end_body
\end_document
