#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
\myTOC
\clearpage
\pagenumbering{arabic}
}
\end_preamble
\use_default_options true
\begin_modules
logicalmkup
\end_modules
\language english
\inputencoding utf8-plain
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 4
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Modern web applications are becoming more and more complex, with users expecting
 more and more automation of menial tasks such as spelling correction and
 autocompletion of text.
 This leads to web applications becoming larger and more complex, which
 in turn means that they are becoming more error prone<TODO: reference?>.
 One large source of errors in web applications is the absence of type safety
 in the form of static type checking in most scripting languages aimed at
 web development, such as JavaScript or PHP 
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js,type-system-dyn-web"

\end_inset

.
 One solution to this problem is providing an extra layer of abstraction
 on top of these scripts, that in turn can be subject to static type checking.
 For example another, already existing, programming language that has these
 features can be used 
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js,HTML-in-haskell,CGI-haskell"

\end_inset

.
 
\end_layout

\begin_layout Standard
Haskell is one such language, designed with type-safety as one of the major
 concerns <TODO:ref: ?>.
 By compiling Haskell directly to JavaScript, we use its strong type system
 to guard against some of the errors that are hard to avoid when writing
 large and complex applications with a dynamically typed language such as
 JavaScript, while still leveraging the wide range of compatible runtime
 environments for JavaScript code.
 <TODO: better formulation plox> 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<TODO: a nicer introduction might be in order? >
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Using Haskell for type safe web-programming is not a new concept.
 Several different approaches have been suggested; the use of Haskell to
 model HTML
\begin_inset CommandInset citation
LatexCommand cite
key "HTML-in-haskell"

\end_inset

 and using server-side Haskell applications to generate CGI
\begin_inset CommandInset citation
LatexCommand cite
key "CGI-haskell"

\end_inset

 are two examples.
 Other languages similar to Haskell have also been suggested for type safe
 web-applications, such as the functional logic language Curry
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js"

\end_inset

.
 
\end_layout

\begin_layout Standard
There are several implementations of compilers from Haskell to JavaScript;
 although none of them has reached a full release stage as of the time of
 writing.
 There are three implementations of JavaScript back-ends for existing Haskell
 compilers; the Utrecht Haskell Compiler has one under development 
\begin_inset CommandInset citation
LatexCommand cite
key "uhc-javascript"

\end_inset

 which is planned for inclusion in an upcoming release, the now defunct
 
\begin_inset CommandInset citation
LatexCommand cite
key "yhc-dead"

\end_inset

 York Haskell Compiler had one, coupled with a toolkit for web content creation
 
\begin_inset CommandInset citation
LatexCommand cite
key "yhc-web-toolkit"

\end_inset

, and there is one in development as a back-end for the Glasgow Haskell
 Compiler which is in its alpha stage at the time of writing 
\begin_inset CommandInset citation
LatexCommand cite
key "ghcjs"

\end_inset

.
 
\end_layout

\begin_layout Standard
There are also at least one other attempt to implement Haskell directly
 in JavaScript, called Haskell in JavaScript, which is an online interpreter
 
\begin_inset CommandInset citation
LatexCommand cite
key "hiji"

\end_inset

.
 
\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
The purpose of this project is to implement a Haskell compiler that generates
 JavaScript code.
 The compiler is to be written entirely in JavaScript, to ensure compatibility
 with most major modern browsers, and relieve users of the burden of having
 to download and install a compiler to their system.
 A JavaScript based graphical user interface with a text-editor and a code
 interpreter will also be developed.
 The code interpreter will enable users to run their programs, and execute
 Haskell expressions directly in the editor, in the vein of the Glasgow
 Haskell Compiler's GHCi, or the Hugs interpreter.
 The compiler is to serve as a proof of concept for developing web applications
 in Haskell in an online environment.
 <TODO: extend and elaborate!>
\end_layout

\begin_layout Chapter
Theoretical background
\end_layout

\begin_layout Section
Introduction to Haskell
\end_layout

\begin_layout Standard
This section contains a quick introduction to Haskell for readers unfamiliar
 with or new to Haskell and/or functional languages.
 It consists of a very general overview, followed by separate sub chapters
 with details about specific features.
\end_layout

\begin_layout Standard
Haskell is a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
lazy
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
purely functional
\end_layout

\end_inset

 programming language with 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
strong static typing
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
type inference
\end_layout

\end_inset

.
 A program in Haskell consists of one or more modules, interconnected by
 their import and export specifications.
 The contents of a module is a set of top-level declarations, which can
 be, among others, function declarations, datatype declarations and typeclass
 declarations.
 Functions consist of a name, a set of arguments and an expression, that
 expresses the result of the function when applied to its arguments.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being lazy means that an expression is only evaluated when its result is
 needed.
 Any expression whose result is not used is simply ignored.
 This enables lazy languages to feature some things that are otherwise impossibl
e, such as infinite data structures.
 Since the data structure is lazy, only the part that is needed is calculated.
 For example, a list of infinite length can be described in Haskell like
 so:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x = [1..]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This declaration assigns to the variable x an expression that calculates
 an infinite list containing all integers > 0 in rising order.
 While an expression calculating this in a strict language would never terminate
 as the set of integers > 0 is infinite, a lazy language only calculates
 the needed parts, e.g:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
take 5 x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where take is a function that returns a list consisting of the first n elements
 in a list, only needs the first 5 elements of x, so no more than 5 elements
 are computed.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
simple examples of Haskell code?
\end_layout

\begin_layout Subsection
Functions 
\end_layout

\begin_layout Standard
Being a purely functional language, Haskell's functions do not have side
 effects, i.e.
 they only compute values given their arguments.
 There is no update of variables.
\end_layout

\begin_layout Standard
Another feature of purely functional languages is that functions are first-class
 objects.
 This means that functions can be passed around as arguments to other functions,
 be returned as the result of a function or created at runtime.
 This enables the creation of 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
higher order functions
\end_layout

\end_inset

, generalized functions that use other functions as arguments.
 For example, the function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
filter
\end_layout

\end_inset

 from the Haskell standard libraries takes a function, which takes one argument
 and returns a boolean, and a list.
 The function then applies the supplied function to each element in the
 list and returns a new list with all elements for which the supplied function
 returned 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A Haskell function can either be named, meaning it is declared with a name
 somewhere in the program, either as a top-level definition or as a local
 function inside a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expression, or anonymous as lambda expressions.
 Function declarations take the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
name
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
arg
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 arg
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
expression
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
name
\end_layout

\end_inset

 is any identifier starting with a lower case letter, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
arg
\end_layout

\end_inset

 1 through n is a series of arguments and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
expression
\end_layout

\end_inset

 is the expression that denotes the result of the function.
 It is possible to define functions as infix operators in the same way as
 ordinary functions, complete with custom precedence levels.
 
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Standard
All values in haskell have a type.
 The type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int -> Int
\end_layout

\end_inset

 represents a function which takes a value of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 and produces a result of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is possible to write a function that takes values that may be of more
 than one type.
 To acheive that, one uses 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type variables
\end_layout

\end_inset

, which are written with lower-case letters.
\end_layout

\begin_layout Standard
A function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
id :: a -> a
\end_layout

\end_inset

 (where
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
::
\end_layout

\end_inset

is read as 
\begin_inset Quotes eld
\end_inset

has type
\begin_inset Quotes erd
\end_inset

) is therefore a function that takes a value of any type and produces a
 result of the same type.
\end_layout

\begin_layout Standard
This is called a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
polymorphic type
\end_layout

\end_inset

, as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 can have a different type depending on how it is used, as the type variable
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

 can be replaced with different types.
\end_layout

\begin_layout Standard
Types can have 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type parameters
\end_layout

\end_inset

, which is necessary for collections if one wants to be able to use them
 where all values have the same type, but be able to choose that type.
\end_layout

\begin_layout Standard
A list of integers is written 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[Int]
\end_layout

\end_inset

, and a function that computes the length of a list as an 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 would have type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[a] -> Int
\end_layout

\end_inset

 as it would work regardless of the type of the values in the list.
 Note however that all the values must have the same type.
\end_layout

\begin_layout Standard
The list type is built-in.
 More generally, a type can be applied to any number of types as in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Array Int Double
\end_layout

\end_inset

 , which is an 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Array
\end_layout

\end_inset

 with indices of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 and stores values of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Type declarations
\begin_inset CommandInset label
LatexCommand label
name "sub:Type-declarations"

\end_inset


\end_layout

\begin_layout Standard
New types can be created.
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
data Tree a = Leaf | Node a (Tree a) (Tree a)
\end_layout

\end_inset

 declares a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type constructor
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 which can be applied to any type that one wants the values in the tree
 to have.
 It also declares the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
data constructor
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Leaf
\end_layout

\end_inset

 which represents an empty tree, and the data constructor 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Node
\end_layout

\end_inset

 which is used to construct a new tree given a value to store in the root
 node of the tree, and the left and right sub-tree.
\end_layout

\begin_layout Standard
The built-in lists have the special type constructor 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

, and the data constructors 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: ∀a.
 [a]
\end_layout

\end_inset

 (the empty list) and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:) :: ∀a.
 a -> [a] -> [a]
\end_layout

\end_inset

 (creating a new list given a first element and the rest of the elements).
\end_layout

\begin_layout Subsection
Pattern matching 
\end_layout

\begin_layout Standard
Pattern matching is a conditional construct that matches an expression 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 to a set of predefined patterns paired with expressions, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

, in a fixed order.
 Matching can be done on data constructors of any arity, primitive values
 such as integers, and variables.
 Matching an expression to a variable will always succeed and, in addition,
 bind the value matched to the variable for use in the 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

.
 The first pattern to match 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 has its corresponding 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 evaluated with any variable bindings defined in the pattern0.
 Pattern matching is used in several places in Haskell, most notably function
 definitions, where they allow specifying different function behaviour depending
 on the arguments given, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
<TODO: fill in later.
 how much do we need here? there are a lot of expressions>
\end_layout

\begin_layout Subsection
Module system
\end_layout

\begin_layout Standard
Haskell’s module system is its main method of encapsulation.
 Apart from local variables in a certain function, it is the only way to
 determine whether something is known (i.e.
 in scope) or not.
 Each module has a name, a set of imports, a set of exports and a body containin
g top-level declatiations.
 The specification of these is optional, with defaults being the module
 name “Main”, the empty import set and the export set containing all top-level
 declarations.
 
\end_layout

\begin_layout Standard
By specifying exports, nothing defined in the module that is not in the
 export space can be accessed by an importing module.
 It is also allowed to specify the export of imported modules or their respectiv
e exports.
 This way, if module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

 imports module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

 and module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C
\end_layout

\end_inset

 imports module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

, it is possible for module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C
\end_layout

\end_inset

 to also have imported some defnintions defined in module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

 (or even module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

's entire export set), depending on what module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

's export set is.
\end_layout

\begin_layout Standard
It is also possible for a module to specify what it will import from another
 module, either as an inclusive specification or as an exclusive specification
 (using the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hiding
\end_layout

\end_inset

 keyword).
\end_layout

\begin_layout Standard
One important feature of Haskell's module system is that unlike, for example,
 Java, it is permitted for a group of modules to import each other.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction to Compilation
\end_layout

\begin_layout Standard
This chapter is intended as an introduction to the general concepts of compilati
on for readers who have little or no experience with the inner workings
 of compilers.
 The approach to compilation described here is not the only one, and only
 describes the compilation steps used in JSHC.
 For a more general and in-depth view of compilers and compilation, 
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

 is recommended.
 
\end_layout

\begin_layout Standard
A compiler is a program that, given program code, produceTop level namespace?s
 new code in another language, the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
target language
\end_layout

\end_inset

.
 Common examples of compilers' target languages are machine code in the
 case of the GNU C Compiler <TODO: ref>, bytecode to be run in a virtual
 machine in the case of Java <TODO: ref> or another high level programming
 language in the case of the Glasgow Haskell Compiler, which can compile
 to C <TODO: ref>.
 
\end_layout

\begin_layout Standard
A compiler consists of two main parts; the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
front-end
\end_layout

\end_inset

 and the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
back-end
\end_layout

\end_inset

.
 The front-end takes the program code and creates an abstract representation
 of it, and the back-end takes that representation and converts it into
 the target language.
\end_layout

\begin_layout Subsection
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the first part of the front-end, and is the process
 by which the compiler takes the program code in the form of an input string,
 and parses it into a list of separate tokens, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
lexemes
\end_layout

\end_inset

, which are the smallest significant components in a programming language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 1.2.
\end_layout

\begin_layout Standard
For example, given a program in a simple language with Haskell-like syntax
 with a source code that looks like this:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fun x y = x + y
\end_layout

\end_inset


\end_layout

\begin_layout Standard
a lexer could generate a list of tokens in this vein:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[fun,x,y,=,x,+,y]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parsing
\end_layout

\begin_layout Standard
Parsing is the second part of the front-end and takes the list of lexemes
 and interprets it according to a grammar, creating a data structure containing
 an abstract representation of the code, called the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
abstract syntax tree
\end_layout

\end_inset

.
 The abstract syntax tree is a tree (or tree-like) graph with nodes representing
 the application of a certain rule in the grammar.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename adsgadgs.png
	lyxscale 50
	width 14cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graphic representation of an AST of a function definition in a simple language
 with Haskell- like syntax.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Semantic analysis
\end_layout

\begin_layout Standard
Semantic analysis gathers various semantic properties of the source program,
 to check for errors and to use later on in the compilation process.
 One common part of semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type checking
\end_layout

\end_inset

, where the compiler searches the abstract syntax tree for type inconsistencies.
 For example, in many languages, adding a boolean to an integer is not a
 valid expression, an error which would be caught by the type checker.
 Another common part of the semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
name checking
\end_layout

\end_inset

, where the compiler checks whether there are any ambiguities in variable
 names used, and whether used variables are in scope where they are used.
\end_layout

\begin_layout Standard
Other operations on the syntax tree, such as reduction of complex constructs
 into simpler, more general constructs can also be done as part of the semantic
 analysis.
 This is done to simplify the code generation process.
 Some code optimizations that are independent of the target language used
 can also be performed at this stage.
 
\end_layout

\begin_layout Subsection
Intermediate representation
\end_layout

\begin_layout Standard
After passing through the compiler front-end, the source program has been
 converted into an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
intermediate representation
\end_layout

\end_inset

, which will later be used as input for the back-end.
 The intermediate representation can take many forms, for example an abstract
 syntax tree, code in another high-level programming language, or some low-level
 code (for example three-address code)
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 1.2.
 
\end_layout

\begin_layout Subsection
Back-end
\end_layout

\begin_layout Standard
The back-end is the final part of a compiler.
 The main function of the back-end is code generation, which is the process
 of taking the intermediate representation and producing a semantically
 equivalent program in the target language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 8.
 The back-end can also fill other functions such as performing code optimization
s that are specific to the target language.
 
\end_layout

\begin_layout Section
Compiling Haskell
\end_layout

\begin_layout Standard
In this section, we present a more detailed introduction to concepts that
 are required to understand the various steps in the compilation of Haskell.
 <TODO: is this really an OK intro to this section?> 
\end_layout

\begin_layout Subsection
Advanced features of the type system 
\end_layout

\begin_layout Subsubsection
Quantification of types
\end_layout

\begin_layout Standard
Type variables, just as ordinary variables must be declared and used variables
 must be in scope of a declaration.
\end_layout

\begin_layout Standard
The declaration of variables is called 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
quantification
\end_layout

\end_inset

.
 A variable that is not declared is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
free
\end_layout

\end_inset

, and a variable that is declared is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
bound
\end_layout

\end_inset

 (by the quantification).
\end_layout

\begin_layout Standard
When writing a type signature in haskell, the quantification is implicit.
\end_layout

\begin_layout Standard
This means that a type signature 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[a] -> [a]
\end_layout

\end_inset

 is actually 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
∀a.
 [a] -> [a]
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
∀
\end_layout

\end_inset

 binds the type variable 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The implicit quantification of type signatures binds all type variables
 in the signature.
\end_layout

\begin_layout Standard
All type signatures written in a program and inferred by the compiler are
 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
rank-1 polymorphic types
\end_layout

\end_inset

, which means that the type given to a value begins with a quantification
 of all the type variables that occur in it, followed by the rest of the
 type which does not contain any quantifications.
 This makes the type system simpler.
\end_layout

\begin_layout Subsubsection
Kinds
\end_layout

\begin_layout Standard
Given the datatype declared in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Type-declarations"

\end_inset

, the function type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree -> Tree
\end_layout

\end_inset

 is invalid as the type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 has a type parameter.
\end_layout

\begin_layout Standard
To detect these errors, all types and type constructors have a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
kind
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The kind of all types is 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A function type is valid if both the argument and result type have kind
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The kind of the type constructors 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 is 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
* -> *
\end_layout

\end_inset

, which means that they take a type and produce a type.
 They must therefore be applied to a type which is not missing any arguments
 (i.e have kind 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

), and will result in a type of kind 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Instantiation of types
\end_layout

\begin_layout Standard
When using a data constructor such as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: ∀a.[a]
\end_layout

\end_inset

, one would want to use it with lists with different element types in different
 locations.
\end_layout

\begin_layout Standard
This is achieved by replacing all bound type variables in the type with
 new type variables wherever it is used.
\end_layout

\begin_layout Standard
These type variables are now free, but will be bound after the type of the
 expression has been inferred unless they are eliminated by the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Type inference
\end_layout

\begin_layout Standard
If one makes a declaration 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
y = x : []
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset

, one will have:
\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:) :: "a -> [a] -> [a]"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: [b]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
b
\end_layout

\end_inset

 are free type variables.
\end_layout

\begin_layout Standard
To replace the type variables with types, one uses type inference which
 creates type constraint based upon how
\end_layout

\begin_layout Standard
the types are used.
\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x
\end_layout

\end_inset

 is the 1st argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = Int
\end_layout

\end_inset

 is created.
\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 is the 2nd argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[b] = [a]
\end_layout

\end_inset

 is created, which gives the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = b
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type inference algorithm must assign a single type to each of the free
 type variables such that all the constraints are satisified.
\end_layout

\begin_layout Standard
If there is more than one possible assignment, then the type is called ambiguous
, and is an error, unless a default
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

,chapter 4.3.4, type can be chosen.
\end_layout

\begin_layout Standard
If there is no possible assignment, then an error will arise from the constraint
s.
\end_layout

\begin_layout Standard
In this case, there is only a single possible assignment, and the inferred
 types are:
\end_layout

\begin_layout Itemize
(:) :: Int -> [Int] -> [Int]
\end_layout

\begin_layout Itemize
[] :: [Int]
\end_layout

\begin_layout Itemize
y :: [Int]
\end_layout

\begin_layout Standard
<TODO: Example using function application and abstraction ?>
\end_layout

\begin_layout Subsection
Dependency groups
\end_layout

\begin_layout Standard
Since modules can mutually depend on each other, there can be a cycle in
 the dependencies between modules.
\end_layout

\begin_layout Standard
If a module A and a module B depends on each other by importing functions
 from the other module, one can not analyse one before the other, as the
 imported functions will be missing.
\end_layout

\begin_layout Standard
To solve this, one must analyse A and B together.
\end_layout

\begin_layout Standard
More generally, one creates a dependency group for any set of modules that
 creates a dependency cycle such as A depends on B, B depends on C, and
 C depends on A.
\end_layout

\begin_layout Standard
The dependency groups are the strongly connected components in the directed
 graph of dependencies between single modules.
\end_layout

\begin_layout Standard
After they have been computed, the resulting graph is a directed acyclic
 graph (DAG) where nodes are dependency groups, and the edges are the dependenci
es between the groups.
\end_layout

\begin_layout Standard
As there are no cycles in the dependencies between the groups, it is possible
 to traverse the groups in dependency order (a reverse topological ordering).
\end_layout

\begin_layout Standard
The Haskell standard 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 mentions dependency groups in Chapters 4.5.1, 4.5.2, and 4.6, related to different
 topics.
\end_layout

\begin_layout Standard
This concept is used in several places of the compiler.
 It is needed to describe sets of modules that depend on each other, sets
 of top-level declarations that depend on each other (even between different
 modules), and declarations in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

/
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Standard
An example of dependencies between local definitions is:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f x = let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

even 0 = True 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

even n = odd (n-1)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

odd 0 = False
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

odd n = even (n-1)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in odd x
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
there is a cyclic dependency between the declaration of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
even
\end_layout

\end_inset

 the declaration of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
odd
\end_layout

\end_inset

.
 The same example can be applied to the case where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
even
\end_layout

\end_inset

 and odd 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
are
\end_layout

\end_inset

 top-level declarations.
 Since they mutually depend on each other, type checking needs to be performed
 on both at the same time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename Dependency groups.png
	lyxscale 15
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example module dependency graph.
 The arrows mean 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
imports from
\end_layout

\end_inset

.
 In this example, the dependency groups are {A,B}, {C,D,E}, {G} and {F}.
 On compilation, {A,B} and {G} need to be checked first, then {C,D,E} and
 {F} last.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Laziness
\end_layout

\begin_layout Standard
<TODO: write something here or leave this out? can't think of anything which
 is not described somewhere else right now>
\end_layout

\begin_layout Chapter
Method
\end_layout

\begin_layout Standard
The main part of this project was the development of the compiler itself.
 The first stage of the project was to identify and isolate subgoals and
 -problems that could be reasoned about on their own.
 Before proceeding with any actual implementation, we attempted to identify
 a theoretical solution to each of these subgoals and -problems, to facilitate
 subsequent implementation.
 Examples of such subproblems are type inference and dependency resolution.
 The next stage was to identify larger components of the project that could
 largely be implemented independently.
 Five such components were identified; lexical analyser, parser, semantic
 analyser, code generator and graphical interface.
 Responsibility for these parts was then split between group members.
\end_layout

\begin_layout Standard
Implementation work was largely carried out individually, with regular meetings
 to synchronize efforts and plan ahead.
 To keep work synchronized between meetings, the git version control system
 was used.
\end_layout

\begin_layout Standard
Early on in the project phase, it was determined that several external tools
 wold be needed to facilitate the development of JSHC.
 
\end_layout

\begin_layout Section
PEG.js
\end_layout

\begin_layout Standard
PEG.js
\begin_inset CommandInset citation
LatexCommand cite
key "peg-js"

\end_inset

 is a JavaScript implementation of parsing expression grammars, which is
 an alternative to context-free grammars and regular expressions for defining
 formal languages
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

.
 The definition of a parsing expression grammar is similar in appearance
 to that of a context-free grammar, with a few key differences.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
unordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
|
\end_layout

\end_inset

 is replaced by an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
ordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
/
\end_layout

\end_inset

.
 This means that, instead of accepting a match on any rule in a production,
 a parsing expression grammar always accepts the first rule matched.
 This means that parsing expression grammars are inherently unambiguous.
 If there are two possible matches to a rule, simply match the one that
 occurred first.
 
\end_layout

\begin_layout Standard
Parsing expression grammars also have several operators similar to those
 used in regular expressions.
 There are the repetition operators 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

 which matches zero or more repetitions of a rule, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 which matches one or more repetitions of a rule.
 There is also the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
?
\end_layout

\end_inset

 operator which eiter matches a rule and returns it, or does not match it
 and returns an empty match.
 Just as with the ordered choice, these operators take a greedy approach,
 i.e.
 they always consume the maximum amount of input possible.
 
\end_layout

\begin_layout Standard
Lastly, parsing expression grammars feature the syntactic predicates 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

.
 These match their paired rule, and either fail or succeed without advancing
 the parser position.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 returns an empty match if the match is successful and fails otherwise,
 while 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

 returns an empty match if the match fails and succeeds otherwise.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
PEG.js generates a Packrat
\begin_inset CommandInset citation
LatexCommand cite
key "ford-packrat"

\end_inset

 parser, i.e.
 a top-down recursive descent parser with backtracking.
 To avoid a worst-case scenario of exponential runtime, packrat parsers
 store intermediate results in a table, sacrificing storage space for guaranteed
 linear-time complexity.
 
\end_layout

\begin_layout Standard
PEG.js was chosen for this project due to the suitability of parsing expression
 grammars for writing lexical analysers 
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

 in a concise and intuitive way, as well as for the efficiency of packrat
 parsers.
 
\end_layout

\begin_layout Section
Jison
\end_layout

\begin_layout Standard
Jison
\begin_inset CommandInset citation
LatexCommand cite
key "jison"

\end_inset

 is a parser generator for generating JavaScript parsers.
 It takes a context-free grammar in the same format as the input files to
 Bison, apart for parser actions, which are defined in the implementation
 language, which is JavaScript for Jison and C for Bison.
 Just like Bison, the parser generated by Jison is LALR(1) by default
\begin_inset CommandInset citation
LatexCommand cite
key "jison,bison-manual"

\end_inset

, which is the option used for the parser in JSHC.
 
\end_layout

\begin_layout Standard
Jison was chosen mainly because of the familiarity and extensive documentation
 of the Bison notation and functionality, as well as for its powerful constructs
 for handling user-defined error handling, something which is essential
 to a Haskell parser 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 10.3.
 The speed and compact size of LALR parsers were also taken into account,
 but not critical for the choice.
 
\end_layout

\begin_layout Section
Ymacs
\end_layout

\begin_layout Standard
As a graphical interface to JSHC, a JavaScript-based Emacs-like text editor
 named Ymacs
\begin_inset CommandInset citation
LatexCommand cite
key "ymacs"

\end_inset

 was chosen.
 The main reasons for this choice were that Ymacs is easily extendable and
 is fully compatible with three of the most widely used web browsers (Mozilla
 Firefox, Google Chrome and Apple Safari
\begin_inset CommandInset citation
LatexCommand cite
key "browser-statistics"

\end_inset

).
 Also, Emacs is a popular coding environments among Haskell programmers
\begin_inset CommandInset citation
LatexCommand cite
key "state-of-haskell"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Ymacs interface design centers around the two central concepts of 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
buffers
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
modes
\end_layout

\end_inset

.
 The word buffer refers to two different entities in the Ymacs program;
 the data structure which stores entered text coupled with the functions
 managing its manipulation, and the text field which is presented a user.
 These two denotations will be used interchangeably, as it should be clear
 from context which denotation is intended.
 While the default Ymacs view contains a single buffer, buffers can be split,
 by creating a new buffer sharing the same screen space.
 Each buffer has a mode, which determines the behaviour of the buffer.
 Modes determine what hot key commands are available, how text is displayed
 etc.
 Due to the transparent nature of JavaScript programs (i.e.
 all code inside a JavaScript application shares the same global namespace),
 modes can be used to completely redefine the behavior of a buffer without
 changing any of the Ymacs source code.
 
\end_layout

\begin_layout Chapter
Result
\end_layout

\begin_layout Standard
<TODO: write an introduction>
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
<TODO: simple description of the syntax used by the compiler.
 reference the appendix.>
\end_layout

\begin_layout Section
User Interface
\end_layout

\begin_layout Standard
The interface is a modified Ymacs environment.
\end_layout

\begin_layout Standard
To modify the behaviour of Ymacs to make it suitable as a development environmen
t for JSHC, several modifications has been done to the default environment.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename JSHCscreen_smaller.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Screen capture of the Ymacs interface and JSHC interpreter as viewed in
 a web browser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An interface for using the compiler has been created.
 It uses Ymacs to allow a user to write modules and then load them in an
 interpreter that uses the compiler.
\end_layout

\begin_layout Standard
The interface provides two initial buffers.
 A buffer named 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
keybindings.txt
\end_layout

\end_inset

 containing the general keybindings which are available regardless of mode,
 and a buffer called 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Main.hs
\end_layout

\end_inset

, which is empty.
 The 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Main.hs
\end_layout

\end_inset

 buffer, and any new buffers that has a name ending with 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.hs
\end_layout

\end_inset

 will have the command 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C-x i
\end_layout

\end_inset

 to show the interpreter terminal in a new frame.
\end_layout

\begin_layout Standard
The interpreter supports a subset of the GHCi commands (table 
\begin_inset CommandInset ref
LatexCommand ref
reference "Interpreter-commands"

\end_inset

), allows evaluation of Haskell expressions, and also includes a command
 for evaluation of JavaScript expressions.
\end_layout

\begin_layout Standard
There is auto-completion of commands using 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
TAB
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="4.5in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
command
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:help
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints available commands
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:kind
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes any number of type constructors and prints the kind of each
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:load
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a number of module names of modules to load.
 Will find all dependencies and recompile modules as necessary.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the possible arguments to :show
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a Haskell expression which will be compiled.
 If it has no errors, the type of the expression will be printed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:js
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a JavaScript expression and evaluates it.
 If it has no errors, the result will be printed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show path
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the URLs which will be used when loading Haskell modules.
\end_layout

\begin_layout Plain Layout
The default paths are 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hslib/
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hsusr/
\end_layout

\end_inset

 from the root of the source distribution.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the generated JavaScript code of all loaded Haskell modules.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show modules
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the names of the currently loaded modules.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Interpreter commands
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Interpreter-commands"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:implementation"

\end_inset

 shows how the interface (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:User-Interface"

\end_inset

) uses the compiler.
\end_layout

\begin_layout Standard
Given a set of modules to load (the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
target
\end_layout

\end_inset

 set), the compiler will load (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Loading-modules"

\end_inset

) them resulting in the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
loaded
\end_layout

\end_inset

 set, which is set of all required modules unless there was an error.
\end_layout

\begin_layout Standard
The compiler will then compute the dependency groups of the loaded set,
 and traverse the groups in dependency order (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Checking-module-groups"

\end_inset

).
\end_layout

\begin_layout Standard
The compiler will then for each module, translate the AST (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Simplify"

\end_inset

) to the IR, and then generate (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:back-end"

\end_inset

) javascript code.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename gen-prog-structure.png
	lyxscale 50
	width 14.5cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:implementation"

\end_inset


\end_layout

\begin_layout Plain Layout
<TODO:
\end_layout

\begin_layout Plain Layout
* 
\begin_inset Quotes eld
\end_inset

loading modules
\begin_inset Quotes erd
\end_inset

 is missing.
\end_layout

\begin_layout Plain Layout
* 
\begin_inset Quotes eld
\end_inset

Add top-level namespace
\begin_inset Quotes erd
\end_inset

 (not a good name? (see description of this figure)) must be within the
 dependency checking.
\end_layout

\begin_layout Plain Layout
* 
\begin_inset Quotes eld
\end_inset

computing exports
\begin_inset Quotes erd
\end_inset

 is missing.
\end_layout

\begin_layout Plain Layout
* reverse order of 
\begin_inset Quotes eld
\end_inset

code generation
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

AST simplification
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout
>
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Flow of information in the implementation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:User-Interface"

\end_inset

User Interface
\end_layout

\begin_layout Subsubsection
The Haskell mode
\end_layout

\begin_layout Standard
A Haskell mode for buffers containing Haskell code.
 It currently only contains the command 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C-x i
\end_layout

\end_inset

to show the interpreter.
 If the interpreter is visible in a frame, the focus will be changed to
 that buffer, otherwise the current frame is split show it.
 There can only be a single interpreter buffer, so a new interpreter buffer
 is only created if it does not exist.
\end_layout

\begin_layout Subsubsection
The Interpreter terminal
\end_layout

\begin_layout Standard
A terminal is needed to interact with the interpreter properly.
\end_layout

\begin_layout Standard
To modify an ordinary buffer into a terminal, the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ENTER
\end_layout

\end_inset

 key is a Ymacs command that will read the last line of the buffer send
 the command on the line to the interpreter.
 The 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
TAB
\end_layout

\end_inset

 key is a Ymacs command that sends the command on the last line to the interpret
er, and the buffer is modified depending on if there is none, one, or many
 matches.
\end_layout

\begin_layout Standard
The highlighting for the buffer is coloring lines beginning with 
\begin_inset Quotes eld
\end_inset

Error: 
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

> 
\begin_inset Quotes eld
\end_inset

 to make output easier to read.
\end_layout

\begin_layout Standard
When an interpreter buffer is created, the buffer object itself is modified
 to only allow deletions of characters and selections on the user input
 on the last line, and insertion of text is modified so that text is always
 added at the end of the buffer.
 These changes are achieved by replacing existing functions on the buffer
 with new functions that calls the old ones when appropriate.
\end_layout

\begin_layout Subsubsection
Setting modes automatically
\end_layout

\begin_layout Standard
Since no mode is automatically set for new buffers, the creation of a new
 buffer has been modified so that it sets a mode for the buffer based upon
 what the extension of the name of the buffer is.
 This makes it possible to create a new buffer with a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.hs
\end_layout

\end_inset

 extension, and the Haskell mode will be set.
\end_layout

\begin_layout Subsubsection
Interpreter
\end_layout

\begin_layout Standard
The interpreter contains an instance of the compiler, which it uses to load
 code, look up names, and compile expressions.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Loading-modules"

\end_inset

Loading modules
\end_layout

\begin_layout Standard
The loading begins with the module names of a set of modules to load, and
 will search for them in a virtual file system (mapping from module names
 to unparsed strings), a list of URLs (which can refer to files using the
 file:// or http:// protocols).
 Each found module must be parsed in order to find out which modules it
 depends upon.
 Those modules (unless already loaded) must then be found and parsed as
 well.
 This process continues until no more modules are needed, and the minimal
 set of modules that satisfies all the module dependencies has been found.
 In case a module can not be found or there is a parse error, this process
 will still continue and try to satisfy more dependencies and see if there
 are more missing modules or parse errors.
\end_layout

\begin_layout Subsubsection
Lexical analysis
\end_layout

\begin_layout Standard
The lexical analysis in JSHC is performed in several steps.
 <TODO: a good way to init this section?>
\end_layout

\begin_layout Standard
While lexical analysis is often done by having the parser request a token
 from the lexical analyzer, match that token against a rule, request another
 and so on
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 3.1, the layout-dependent syntax of Haskell requires a different
 approach.
 First, the input (i.e.
 the Haskell source code, including whitespace and comments) is parsed into
 an array of tokens in one go.
 This is done by using a parser built using PEG.js that was fed a translation
 (into PEG.js-readable form) of the lexical program structure described in
 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 2.2.
 Second, the generated array of tokens is run through a function that adds
 indentation information to the array in the form of special indentation
 tokens, and annotates tokens with position information.
 Whitespace and comments are discarded as they are no longer needed for
 position information.
 Lastly, this array is fed into an object which interfaces with the parser
 according to the Jison/Bison style API
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 3.1, using the indentation information to generate tokens to convert
 Haskell's layout-dependent syntax into a context-free one.
 
\end_layout

\begin_layout Standard
As an example, the code: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f = let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x = 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

y = 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
generates, after the first and second stages this array of tokens (token
 representation rewritten for readability):
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[{1},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

let
\begin_inset Quotes erd
\end_inset

,{3},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,
\begin_inset Quotes erd
\end_inset

in
\begin_inset Quotes erd
\end_inset

,ID,OP,ID]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where the tokens 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{n}
\end_layout

\end_inset

 designate the start of a block after a newline and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
<n>
\end_layout

\end_inset

 representing a newline where a new block should not begin.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
n
\end_layout

\end_inset

 represents the starting column of the first token on the new line.
 Given this array as input, the last stage of the lexer will deliver to
 the parser tokens representing a context-free version of the code which,
 converted back into Haskell source code, would look like this:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{f = let {x = 1;y = 2} in x + y}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parsing
\end_layout

\begin_layout Standard
The context-free syntax is parsed by a parser implemented using the JISON
 parser generator 
\begin_inset CommandInset citation
LatexCommand cite
key "jison"

\end_inset

.
 The parser and the last step of the lexical analysis work in concert, meaning
 that the lexical analyzer does not process and return all tokens in one
 go, but only sends the parser tokens when asked to.
 To handle certain features of the layout dependent syntax of Haskell, that
 cannot be handled by the lexical analyzer alone, the parser will inform
 the lexical analyzer of any such parse errors, so that the lexer can react
 and send new tokens that solve the problem (c.f.
 the description of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
parse-error
\end_layout

\end_inset

 function in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 10.3).
 
\end_layout

\begin_layout Standard
<TODO: create figure explaining the layout of finding/lexing/parsing>
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Checking-module-groups"

\end_inset

Checking module groups
\end_layout

\begin_layout Standard
For each dependency group of modules checked in dependency order, the compiler
 does the following:
\end_layout

\begin_layout Standard
If some modules are already compiled, they will only be compiled if not
 all of the modules within the same group have previously been compiled.
\end_layout

\begin_layout Standard
For each module, compute the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
tspace
\end_layout

\end_inset

 (the set of declared top-level names in the module), and adding fixity
 information to this name so that it can easily be found later on.
\end_layout

\begin_layout Standard
Resolve the exports (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Export-check"

\end_inset

), which results in the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
espace
\end_layout

\end_inset

 (the set of exported names) being known for each module in the group.
\end_layout

\begin_layout Standard
For each module, check usage of names (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Name-check"

\end_inset

).
\end_layout

\begin_layout Standard
For each module, resolve fixity of operators (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Fixity-Resolution"

\end_inset

).
\end_layout

\begin_layout Standard
Then dependency groups are produced for the top-level declarations of all
 modules in the group.
 The groups are then type checked in dependency order.
\end_layout

\begin_layout Itemize
<TODO: Top level namespace?>
\end_layout

\begin_layout Itemize
Export check: Computes the export space of each module
\end_layout

\begin_layout Itemize
Name check: Checks if names are in scope, and qualifies names referring
 to top-level declarations
\end_layout

\begin_layout Itemize
Fixity resolution: Replace all lists of infix applications with operator
 application
\end_layout

\begin_layout Itemize
Type check: Compute types and kinds.
\end_layout

\begin_layout Subsubsection
Finding and traversing dependency groups
\end_layout

\begin_layout Standard
The implementation for handling dependency groups takes a set of entries,
 where each entry provides a set of names, depends on a set of names, and
 contains a set of items, such as modules or declarations.
\end_layout

\begin_layout Standard
These entries will have to be created from the declarations or modules that
 one will want to create dependency groups for.
\end_layout

\begin_layout Standard
The entries are nodes in a graph where the minimal number of entries are
 merged such that there are no longer any cycles in the graph.
\end_layout

\begin_layout Paragraph
Condensing the graph
\end_layout

\begin_layout Standard
Given a directed graph representing the dependencies, it merges the minimal
 amount of nodes to create a directed acyclic graph.
 This takes O(|E|+|V|) time.
\end_layout

\begin_layout Standard
<TODO: pseudo code for condensing the graph>
\end_layout

\begin_layout Standard
<TODO: time and space analysis ?>
\end_layout

\begin_layout Paragraph
Dependency order traversal
\end_layout

\begin_layout Standard
To traverse the graph in dependency order, an opposide edge is added for
 each edge so that each group not only knows what it depends upon, but also
 which groups depends upon it.
 Each group keeps track of the number of remaining groups that it depends
 on, and for each group that is checked, this number is decreased for all
 groups that depends on it (which are exactly the set of groups accessible
 via the added edges).
 The traversal keeps track of a ready set and waiting set of groups.
 Whenever the number of remaining unchecked dependencies reaches 0, the
 group is moved to the ready set.
\end_layout

\begin_layout Standard
Unless there are missing dependencies (or there are groups which are currently
 being checked), the ready set will never be empty while the waiting set
 is not.
\end_layout

\begin_layout Standard
A group is checked by removing it from the ready set, check it, and then
 inform the traversal algorithm that the group is checked.
\end_layout

\begin_layout Standard
When both sets are empty, the traversal is complete.
\end_layout

\begin_layout Standard
Concurrency is possible, since any number of groups could be taken out from
 the ready set to be checked at the same time.
\end_layout

\begin_layout Standard
<TODO: should there be pseudo code ?>
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Export-check"

\end_inset

Export check
\end_layout

\begin_layout Standard
The implementation gives an error if modules in the same group have a list
 of exports, as this is currently not supported.
 If the modules do not have a list of exports, all top-level declarations
 are exported, which is easy to handle, and is only what is currently supported.
 If there is only a single module in a group, then the export list may exist
 and the exported names are resolved by looking at all top-level declarations
 and imports.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Name-check"

\end_inset

Name check
\end_layout

\begin_layout Standard
This is applied separately on each module in a group.
\end_layout

\begin_layout Standard
Errors is given for missing and ambiguous names.
 Otherwise the name will be qualified with the qualification of what it
 refers to so that the definition can easily be found later on when it is
 non-local.
 The definition needs to be found later on when fixity and type information
 is required.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Fixity-Resolution"

\end_inset

Fixity Resolution
\end_layout

\begin_layout Standard
Fixity resolution is applied separately on each module in a group.
 It is the procedure which, given information on each operator's fixity
 and precedence, calculates in which order the operators in an infix expression
 are to be applied.
 This information is then used to convert the infix expressions into ordinary
 prefix function applications.
 
\end_layout

\begin_layout Standard
For example, the expression 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
2 + 3 * 10
\end_layout

\end_inset

 could evaluate to 32 or 50, depending on the fixity and precedence of the
 operators 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
 The algorithm looks up the fixity information of the operators, and finds
 out that they are both left fix operators with precedences of 6 and 7 respectiv
ely.
 Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

 has the higher precedence, it should be applied before 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

, resulting in the application expression 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(+) 2 ((*) 3 10)
\end_layout

\end_inset

, which evaluates to 32, as expected by anyone familiar with the operators'
 precedence in ordinary arithmetics.
 
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Type-checking"

\end_inset

Type checking
\end_layout

\begin_layout Standard
The monomorphism restriction (see 4.5.5 in the report) is not implemented.
\end_layout

\begin_layout Standard
Since type classes are not implemented, the type system only implements
 the parametric polymorphism.
\end_layout

\begin_layout Standard
Type checking is applied on dependency groups over all declarations from
 all modules in the group, since one can not check the top-level declarations
 of a single module in dependency order as they may depend on types from
 top-declarations in other modules within the same group.
\end_layout

\begin_layout Standard
While type checking, the algorithm keeps track of local names and type variables
, and also the constraints using a map from the type variables to types
 to which they are constrained.
\end_layout

\begin_layout Paragraph
The constrain map
\end_layout

\begin_layout Standard
The constraint map maps type variables (LHS) to types (RHS).
\end_layout

\begin_layout Standard
It simply represents the types that type variables are constrained to.
\end_layout

\begin_layout Standard
Type variables are only given a type if they are constrained, so all new
 type variables will not be in the map until a constraint is placed upon
 them.
\end_layout

\begin_layout Standard
Type variables on the LHS may not occur in their corresponding RHS as this
 would create an infinite type, and may only occur in the RHS of other variables
 if the other RHSs are such that there is no infinite type.
 This invariant is maintained when new constrained are inserted.
\end_layout

\begin_layout Standard
The reason for using a constraint map is that type errors are discovered
 as soon as possible, so a type error in a sub-expression will be given
 for the sub-expression instead of the expression as a whole if the constraints
 were just gathered and then checked after computing all of them, which
 is the usual description of solving the constraints <reference to 
\begin_inset Quotes eld
\end_inset

Pierce, B.
 C.
 2002 Types and Programming Languages.
 MIT Press.
\begin_inset Quotes erd
\end_inset

 chapter 22 or so>
\end_layout

\begin_layout Paragraph
Adding constraints
\end_layout

\begin_layout Standard
<TODO: describe what happens when adding constraints such as 
\begin_inset Quotes eld
\end_inset

a -> b = c -> d
\begin_inset Quotes erd
\end_inset

.
 Will be split into two separate constraints, which will each cause elimination
 of a type variable as the constraint specifies that two constraints are
 equal.>
\end_layout

\begin_layout Paragraph
Checking a group of declared names
\end_layout

\begin_layout Standard
Each declared name in a group is given a type variable.
 As the declarations are checked, the type variables for the names will
 be constrained depending on what the declaration contains.
 After all declarations in the group have been checked, all free type variables
 occurring in the types bound to the type variables of each declared name
 are quantified since they only occur inside the declarations.
\end_layout

\begin_layout Paragraph
Checking declarations
\end_layout

\begin_layout Standard
<TODO: Probably need a few concrete examples.
 Should be done in a similar way to as it was done in the theory chapter,
 but need to show the constraint map.
 need to give example of nested let-declarations to show the point of it
 all.>
\end_layout

\begin_layout Standard
It is necessary to use dependency groups and check in dependency group order
 to give the correct type, instead of checking all of the declarations as
 a single group <TODO: example needed.
 check the Haskell report.
 related to the monomorphism restriction.>
\end_layout

\begin_layout Standard
Checks for missing identifiers (type variables, types, functions, etc..),
 instances, and infer type.
 Adds type information to the AST.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Simplify"

\end_inset

Translation to the intermediate representation
\end_layout

\begin_layout Standard
This step translates the AST to the intermediate representation used by
 the back-end, see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:B.2Intermediate-representation"

\end_inset

 for details.
 Several constructs are reduced to other, simpler and more general, constructs
 to create a kernel, which is a small subset of Haskell.
 The constructs that can be reduced in this way can be seen as syntactic
 sugar of the kernel
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 1.2.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Conditional expressions are simplified by converting 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
if
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e1
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
then
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e2
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
else
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e3
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
to a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expression of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e1
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
of
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{True ->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e2
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
;
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
False -> 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e3
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expressions both bind expressions to local variables, something which is
 possible to express with 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions.
 Thus, expressions of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
decls
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
in
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
decls
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
decls
\end_layout

\end_inset

 is a set of declarations of the form 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
are converted to expressions of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case (
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) of 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
 ->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
 }
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pattern matching in function definitions is converted by merging function
 clauses of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 ...
 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 is the function identifier, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\end_layout

\end_inset

 is any argument patterns and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 is the right hand side of each clause, into one single clause of the form
 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
= case (
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) of {
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
; ...
 ;
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 through 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 are variable pattern matches created to preserve function arity.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Function declarations with arguments are converted into a binding from the
 function name to a sequence of lambda expressions corresponding to the
 arity of the function.
 Functions of the form: 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

= 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 is the function identifier, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 through 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 are function arguments and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 is the right hand side of the function, are converted into functions of
 the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id 
\end_layout

\end_inset

 = 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntactic sugar for lists, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[ 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
: : :
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
 ]
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 through 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 are arbitrary expressions, is converted into applications of the list construct
or (cons), resulting in expressions of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
((:)
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
( 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
:::
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[])))
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Note that the cons operator is written in prefix notation, as an ordinary
 data constructor, instead of as an infix constructor, as is normally done
 when writing source code.
 This is because at this stage operator applications have already been removed
 from the language by the fixity resolution algorithm described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Fixity-Resolution"

\end_inset

.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:back-end"

\end_inset

Compiler back-end
\end_layout

\begin_layout Standard
JSHC's back-end takes an intermediate representation in the form of an AST
 and compiles it to JavaScript code.
 
\end_layout

\begin_layout Subsubsection
Code generation
\end_layout

\begin_layout Standard
The code generation step generates JavaScript code representing the compiled
 modules.
 This code can then be accessed and executed by any JavaScript interpreter.
 For the generated code to be as easy to use in an external application
 as possible, the code generation preserves the names of as many identifiers
 as possible.
 This also allows for easier debugging of the generated code.
 Below follows a walkthrough of how components of the intermediate representatio
n (Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:B.2Intermediate-representation"

\end_inset

) are translated to JavaScript.
 If not defined in the text, names in italics refer to the an item name
 in the description of the corresponding node in the intermediate representation
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "sec:B.2Intermediate-representation"

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Modules are represented as JavaScript objects of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset

 is a module prefix specified by the user.
 Both 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 can include 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.
\end_layout

\end_inset

 , which will create a nested object.
 E.g.
 substituting 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset

 for 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
JSHC.mod
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 for 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Data.List
\end_layout

\end_inset

 will create the JavaScript object 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
JSHC.mod.Data.List
\end_layout

\end_inset

.
 Following paragraphs will use 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 to refer to the concatenation
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only top-level declarations that generate any code are function declarations.
 They are compiled as members of the object representing the module, using
 JavaScript's associative array notation to enable members with non-alphanumeric
 characters as identifiers.
 This creates statements of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
ident
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes erd
\end_inset

] =
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 is the code generated by the expression in 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lambda expressions are compiled 
\end_layout

\begin_layout Standard
As an example, compiling the following program with the module prefix 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

JSHC.Ymacs.modules
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

module Main where
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f x y = x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
would generate the code: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

JSHC.Ymacs.modules.Main["f"] = function(x){ return 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

function(y){ return 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

JSHC.Ymacs.modules.Prelude["+"]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(JSHC.TC(function() {return x}))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(JSHC.TC(function() {return y}))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

}};
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
JSHC.TC
\end_layout

\end_inset

 is a function from JSHC's internal libraries that wraps its arguments in
 a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 object, creating a lazy value.
 
\end_layout

\begin_layout Subsubsection
Internal libraries
\end_layout

\begin_layout Standard
To implement basic some functionality of the generated code which cannot
 be efficiently defined in Haskell (or is needed for our implementation
 to operate at all), an internal JavaScript library was developed.
 This library contains functions for handling integer arithmetics, arithmetic
 comparisons, laziness and pattern matching.
 
\end_layout

\begin_layout Standard
Since JavaScript does not have integers built in, the arithmetics for the
 Haskell integer types requires internal libraries that manage integer behaviour
, such as overflow.
\end_layout

\begin_layout Standard
Laziness is implemented by creating a JavaScript object called 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

.
 When a lazy expression is created, the strict JavaScript expression is
 wrapped in a JavaScript closure, which is subsequently wrapped in a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 object.
 When the lazy value is needed, a method of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 object is called, which evaluates the closure and assigns the value to
 a variable.
 <TODO: perhaps more elaboration?>
\end_layout

\begin_layout Standard
Pattern matching is handled by an internal function that is sent an expression,
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

, and an array of pairs 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{pattern,rhs}
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pattern
\end_layout

\end_inset

 is the pattern to match the result of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 to, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 is a function that takes any bindings made in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pattern
\end_layout

\end_inset

 as arguments, and returns the right hand side expression of that particular
 pattern match alternative.
 The pairs are then matched sequentially, one at a time until a match is
 found or there are no more alternatives to match.
\end_layout

\begin_layout Subsection
Standard libraries
\end_layout

\begin_layout Standard
The standard Haskell libraries used for JSHC are a subset of the libraries
 described in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

.
 Included in these are basic integer arithmetic functions, arithmetic comparison
s, the Bool type with operators and functions, operators and functions for
 function compisition and some basic functions on lists.
\end_layout

\begin_layout Chapter
Discussion
\end_layout

\begin_layout Section
Implementation details
\end_layout

\begin_layout Subsection
Export checking
\end_layout

\begin_layout Standard
<TODO: not finding any resources on implementing it.
 usually people write about avoid/resolve cycles by rewriting the modules>
\end_layout

\begin_layout Standard
It is unclear to us what is the best way of computing the set of exported
 names within dependency groups of modules.
\end_layout

\begin_layout Standard
Resolving exports is complicated.
 The Haskell report only explains the syntax and semantics of export lists.
\end_layout

\begin_layout Standard
Example of a missing name:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module A ( x ) where
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import B
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module B ( x ) where
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import C
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module C ( x ) where
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import A
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Names could also be ambiguous.
\end_layout

\begin_layout Subsection
Dependency checking
\end_layout

\begin_layout Standard
Dependency checking was not expected to be as big a part of the implementation
 as it turned out to be.
 It is something which one does not see as a Haskell user, and is not needed
 in many other languages that we have experience with, such as C or Java,
 as they do not have cyclic dependencies between language constructs.
 It is also only scarcely mentioned in the specification (
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 chapters 4.5 and 4.6), which somewhat hides the fact that it is a central
 concept in the workings of a Haskell compiler.
\end_layout

\begin_layout Standard
The dependency checking was not expected.
 It is not needed in many other languages as they do not have cyclic dependencie
s between language constructs together with a lack of specification.
 It is this combination that causes the groups that need to be analyzed
 together instead of simply using an export specification of a module or
 a declared type of a function.
 <TODO: keep or not? if so, rewrite a bit for clarity.>
\end_layout

\begin_layout Section
Design choices
\end_layout

\begin_layout Itemize
Why write compiler in JavaScript?
\end_layout

\begin_layout Itemize
non-JavaScript applications
\end_layout

\begin_layout Section
Comparison with other implementations 
\end_layout

\begin_layout Standard
<TODO: is this something we can do well in a short time frame?>
\end_layout

\begin_layout Subsection
Other possible solutions to client-side Haskell
\end_layout

\begin_layout Standard
If making a plug-in, one still required writing a back-end to JavaScript
 and implementing an FFI to JavaScript code.
\end_layout

\begin_layout Standard
If compiling an existing compiler like GHC to JavaScript, it would require
 an existing JavaScript back-end, and the performance of it would be important.
 There seems like there would be issues with how I/O is used within the
 compiler since it is not available in JavaScript, which would mean that
 the compiler need to be modified and can not just be compiled as is.
\end_layout

\begin_layout Subsection
GHC
\end_layout

\begin_layout Standard
<TODO: Anything to write here?>
\end_layout

\begin_layout Subsection
HIJi (project from previous year)
\end_layout

\begin_layout Standard
From the report, it is unclear if one can load more than one module, and
 if cycles in the dependencies of module and declaration are handled as
 it is not mentioned.
\end_layout

\begin_layout Section
Future work on JSHC
\end_layout

\begin_layout Subsection
Loading files asynchronously
\end_layout

\begin_layout Standard
This is not difficult, but since only local files or files on the same domain
 may be accessed, there does not appear to be a reason to implement this.
\end_layout

\begin_layout Subsection
Pretty printer
\end_layout

\begin_layout Standard
To give good error messages related to expressions within functions, a pretty
 printer is required.
 Currently, only the abstract syntax tree is available.
\end_layout

\begin_layout Subsection
Concurrency
\end_layout

\begin_layout Standard
To speed up compilation, the dependency group traversal could be implemented
 to run concurrently, as the implemented algorithm allows for taking out
 many groups which do not depend on each other.
 Even though extensions for concurrency exists, speed is not important in
 the compiler in it
\begin_inset Quotes ers
\end_inset

s current state.
 Lexical analysis and parsing of modules could also benefit from added concurren
cy.
\end_layout

\begin_layout Subsection
FFI: Foreign Function Interface
\end_layout

\begin_layout Standard
Adding an FFI to JavaScript code would simplify the writing of the prelude,
 as primitive operations such as addition could be described using foreign
 imports instead of a name with a special prefix for which the type would
 be stored in the type checker when looking up the name instead of the type
 being written in a foreign function declaration.
\end_layout

\begin_layout Standard
More importantly, it will also allow writing Haskell libraries that wrap
 JavaScript APIs, which would greatly increase the flexibility in the developmen
t capabilities of JSHC.
\end_layout

\begin_layout Subsection
Type classes
\end_layout

\begin_layout Standard
reference to 
\begin_inset Quotes eld
\end_inset

Type classes in Haskell Cordelia Hall, Kevin Hammond, Simon Peyton Jones,
 and Philip Wadler.
 European Symposium On Programming, LNCS 788, Springer Verlag, pp.
 241-256, April 1994.
\begin_inset Quotes erd
\end_inset

 from http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html <TODO: we
 need some text here too.
 reference added to .bib : 
\begin_inset CommandInset citation
LatexCommand cite
key "type-classes-in-haskell"

\end_inset

>
\end_layout

\begin_layout Subsection
Syntax highlighting in the Haskell mode
\end_layout

\begin_layout Section
Issues
\end_layout

\begin_layout Standard
During the course of the project, several issues were 
\end_layout

\begin_layout Subsection
The Haskell grammar
\end_layout

\begin_layout Standard
Certain features of the Haskell grammar occurred to us as peculiar and/or
 problematic when implementing the language.
\end_layout

\begin_layout Standard
The grammar in the Haskell report is at least an LR(2) grammar as it requires
 a lookahead of 2 when reading top declarations <TODO: we should examplify
 this>, and it has conflicts as an LALR grammar.
 This means that it must be rewritten for use in a LALR(1) parser generator
 such as Jison or Bison.
 This is problematic, as rewriting the grammar can be a source of errors
 that can be hard to detect <TODO: ref?>.
 The grammar also contains at least one ambiguity.
 Both the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecl
\end_layout

\end_inset

 and the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gendecl
\end_layout

\end_inset

 have empty productions, and both can be present at the top level.
 Although this ambiguity only applies to programs with empty declarations,
 and should not affect implementations, allowing for ambiguities in the
 formal specification of a language strikes us as bad practice, as it potentiall
y makes the grammar less clear and also harder to implement a parser for.
\end_layout

\begin_layout Standard
Another issue we had was that the specification defines some declarations
 as legal where the semantics are unclear or nonsensical <TODO: can we say
 that in that way?>.
 For example, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
2 = 3
\end_layout

\end_inset

 is a valid top level declaration in Haskell, which, we assume, defines
 a pattern match which can never succeed as it is never reached to begin
 with.
 
\end_layout

\begin_layout Standard
The conflict messages in Jison (and also Bison) are not easy to understand.
 Better explanations of conflicts in these tools is certainly possible.
\end_layout

\begin_layout Subsection
Bugs
\end_layout

\begin_layout Subsection
Interpreter: accessing URLs
\end_layout

\begin_layout Standard
The idea was that the interpreter should support adding paths.
 Unfortunately, the most common browsers prevent getting files from domains
 other than the one that the script is executed on.
 If using chrome/chromium, the security policy even prevents accessing local
 files using the file:// protocol when running scripts from local files,
 so the Ymacs interface must be placed on a web server to work for browsers
 with such a restriction.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "jshc"
options "plain"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
NomenclatureTop level namespace?
\end_layout

\begin_layout Chapter
Syntax reference
\end_layout

\begin_layout Standard
Detailed in this appendix is a reference to the subset of the Haskell syntax
 supported by JSHC, as well as the intermediate representation used by the
 code generation.
 
\end_layout

\begin_layout Section
Context-free syntax
\end_layout

\begin_layout Standard
The same notational convention used in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 is used here, i.e:
\end_layout

\begin_layout Standard
[pattern] : optional
\end_layout

\begin_layout Standard
{pattern} : zero or more repetitions
\end_layout

\begin_layout Standard
(pattern) : grouping
\end_layout

\begin_layout Standard
pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 | pat
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
nonterm -> alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 | alt
\begin_inset Formula $_{\text{2}}$
\end_inset

 | … | alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 : production
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module → module modid [exports] where body 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| body
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body → { impdecls ; topdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { impdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { topdecls }
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecls → impdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; impdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exports → ( export
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , export
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
export → qvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycon [(..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycls [(..) | ( qvar
\begin_inset Formula $_{\text{1}}$
\end_inset

, … , qvar
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| module modid
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecl → import modid [impspec]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (empty declaration)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impspec → ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| hiding ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tycon [ (..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

)] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
cname → var | con
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls → topdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; topdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 0)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl → type simpletype = type
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| data simpletype [= constrs]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| decl
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decls → { decl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; decl
\begin_inset Formula $_{\text{n}}$
\end_inset

 } 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl → gendecl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (funlhs | pat) rhs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gendecl → vars :: type 
\end_layout

\end_inset

(type signature)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fixity [integer] ops 
\end_layout

\end_inset

(fixity declaration)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| 
\end_layout

\end_inset

(empty declaration)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ops → op
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , op
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
vars → var
\begin_inset Formula $_{\text{1}}$
\end_inset

 , …, var
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fixity → infixl | infixr | infix
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
type → btype [-> type] 
\end_layout

\end_inset

(function type)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
btype → [btype] atype 
\end_layout

\end_inset

(type application)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
atype → gtycon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tyvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , type
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple type, k ≥ 2)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ type ] 
\end_layout

\end_inset

(list type)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type ) 
\end_layout

\end_inset

(parenthesized constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gtycon → qtycon
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
simpletype → tycon tyvar
\begin_inset Formula $_{\text{1}}$
\end_inset

 … tyvar
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(k ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constrs → constr
\begin_inset Formula $_{\text{1}}$
\end_inset

 | … | constr
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constr → con [!] atype
\begin_inset Formula $_{\text{1}}$
\end_inset

 … [!] atype
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(arity con = k, k ≥ 0)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
funlhs → var apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| pat varop pat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( funlhs ) apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
rhs → = exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp → infixexp :: type 
\end_layout

\end_inset

(expression type signature)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| infixexp 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
infixexp → lexp qop infixexp 
\end_layout

\end_inset

(infix operator application)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| - infixexp 
\end_layout

\end_inset

(prefix negation)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| lexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lexp → 
\backslash
 apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{n}}$
\end_inset

 -> exp 
\end_layout

\end_inset

(lambda abstraction, n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| let decls in exp 
\end_layout

\end_inset

(let expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| if exp [;] then exp [;] else exp 
\end_layout

\end_inset

(conditional)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| case exp of { alts } 
\end_layout

\end_inset

(case expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fexp → [fexp] aexp 
\end_layout

\end_inset

(function application)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
aexp → qvar 
\end_layout

\end_inset

(variable)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon 
\end_layout

\end_inset

(general constructor)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp ) 
\end_layout

\end_inset

(parenthesized expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple, k ≥ 2)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ] 
\end_layout

\end_inset

(list, k ≥ 1)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts → alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt → pat -> exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat → lpat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lpat → apat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(arity gcon = k, k ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
apat → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon 
\end_layout

\end_inset

(arity gcon = 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| _ 
\end_layout

\end_inset

(wildcard)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat ) 
\end_layout

\end_inset

(parenthesized pattern)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , pat
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple pattern, k ≥ 2)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
var → varid | ( varsym ) 
\end_layout

\end_inset

(variable)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvar → qvarid | ( qvarsym ) 
\end_layout

\end_inset

(qualified variable)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
con → conid | ( consym ) 
\end_layout

\end_inset

(constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qcon → qconid | ( gconsym ) 
\end_layout

\end_inset

(qualified constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varop → varsym | ` varid ` 
\end_layout

\end_inset

(variable operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvarop → qvarsym | ` qvarid ` 
\end_layout

\end_inset

(qualified variable operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
conop → consym | ` conid ` 
\end_layout

\end_inset

(constructor operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qconop → gconsym | ` qconid ` 
\end_layout

\end_inset

(qualified constructor operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
op → varop | conop 
\end_layout

\end_inset

(operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qop → qvarop | qconop 
\end_layout

\end_inset

(qualified operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gconsym → : | qconsym 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Intermediate representation
\begin_inset CommandInset label
LatexCommand label
name "sec:B.2Intermediate-representation"

\end_inset


\end_layout

\begin_layout Standard
For detailing the intermediate representation, these notational conventions
 are used:
\end_layout

\begin_layout Standard
node → { item
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , item
\begin_inset Formula $_{\text{n}}$
\end_inset

}
\end_layout

\begin_layout Standard
item → name: value | [name: value]
\end_layout

\begin_layout Standard
rule
\begin_inset Formula $_{\text{1}}$
\end_inset

 | rule
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
name : the name of a n item inside a node
\end_layout

\begin_layout Standard
value : the value of an item inside a node, values can be both terminals
 and nonterminals
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module -> {name: "module",modid: <modname>, body: <body>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body -> {name: "body", topdecls: <topdecls>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls -> <topdecl>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <topdecl>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl -> {name: "topdecl-decl", decl: <decl>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl -> {name: "decl-fun", ident: <varname>, rhs: exp}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exps -> <exp>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <exp>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp -> {name: "lambda", args: <args>, rhs: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "case", exp: <exp>, alts: <alts>}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "application", exps: <exps>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple", members: <exps>}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
At this stage, it is legal for a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple-pat
\end_layout

\end_inset

 to have 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
members.length == 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "negate", exp: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts -> <alt>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <alt>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt -> {name: "alt", pat <pat> exp: <exp>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pats -> <pat>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <pat>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat -> {name: "conpat", con: dacon, pats: <pats>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple-pat", members: <pats>} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{1}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "wildcard"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
modname -> {name: "modname", id: dacon}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon -> {name: "dacon", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
loc
\end_layout

\end_inset

 is used to determine whether a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname
\end_layout

\end_inset

 is qualified, and what that qualification is.
 At this stage, anything that is not qualified is a local variable.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname -> {name: "varname", id: <STRING>, [loc: <string>]} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{2}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
literal -> {name: "integer-lit", val: <STRING>} 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
STRING -> a javascript String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
NUMBER -> a javascript Number
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<TODO: some significant pieces of the source code, test cases, etc..
 probably an example of how the compiler can be used on a web page>
\end_layout

\end_body
\end_document
