#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass extreport
\begin_preamble
\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
\setmainfont{DejaVu Serif}

\usepackage{fullpage}

\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
\myTOC
\clearpage
\pagenumbering{arabic}
}
\date{}
\end_preamble
\options a4paper
\use_default_options true
\begin_modules
logicalmkup
\end_modules
\language english
\inputencoding utf8-plain
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics xetex
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "JSHC - JavaScript Haskell Compiler"
\pdf_author "Staffan Bjornesjo and Peter Holm"
\pdf_keywords "Haskell JavaScript Compiler"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 4
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename GU-logo.png
	width 14cm

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size giant
JSHC
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard

\size larger
- JavaScript Haskell Compiler
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
\size large
Bachelor
\begin_inset Quotes ers
\end_inset

s thesis in Computer Science
\shape default
\size default

\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\size largest
STAFFAN BJÖRNESJÖ
\end_layout

\begin_layout Standard

\size largest
PETER HOLM
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
University of Gothenburg
\end_layout

\begin_layout Standard
Department of Computer Science and Engineering
\end_layout

\begin_layout Standard
Göteborg, Sverige 2011
\end_layout

\begin_layout Standard
Kandidatarbete/rapport nr 2011:032
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
JSHC
\end_layout

\begin_layout Standard
JavaScript Haskell Compiler
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
© Staffan Björnesjö, Peter Holm
\end_layout

\begin_layout Standard
June 2011
\end_layout

\begin_layout Standard
Department of Computer Science and Engineering
\end_layout

\begin_layout Standard
University of Gothenburg
\end_layout

\begin_layout Standard
SE-412 96 Göteborg
\end_layout

\begin_layout Standard
Sweden
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 7cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Development of large web based applications using scripting languages such
 as PHP or JavaScript can be difficult given the lack of static type checking
 and abstraction through module systems in many such languages.
 We argue that static type checking and module systems can help programmers
 avoid common errors when developing large web applications.
 The literature indicates that adding an extra layer of abstraction on top
 of the scripting languages that provides these features can be a solution
 to this problem.
 
\end_layout

\begin_layout Abstract
We suggest a solution where the statically typed functional language Haskell
 is compiled to JavaScript code, enabling programmers to create web applications
 in a modular and type safe environment.
 
\end_layout

\begin_layout Abstract
An implementation of a compiler, supporting compilation of a subset Haskell
 to JavaScript, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
JSHC
\end_layout

\end_inset

, is presented as a proof of concept.
 The compiler has a graphical interface in the form of an Emacs-like text
 editor extended to contain an interpreter terminal, to allow execution
 of arbitrary expressions.
 To allow for client-side compilation, the compiler is written entirely
 in JavaScript.
 
\end_layout

\begin_layout Abstract
A comparison between 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
JSHC
\end_layout

\end_inset

 and another JavaScript based Haskell implementation is presented, as well
 as some unexpected issues with the Haskell specification.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
renewcommand
\backslash
abstractname{Sammanfattning} 
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Utveckling av stora webbaserade applikationer med hjälp av skriptspråk såsom
 PHP och JavaScript kan vara svårt i och med avsaknaden av statisk typkontroll
 och abstraktion genom modulsystem i många sådana språk.
 Vi argumenterar för att statisk typkontroll och modulsystem kan hjälpa
 programmerare att undvika vanliga fel vid utveckling av stora webapplikationer.
 Literaturen pekar på att ett extra lager med abstraktion ovanpå skriptspråken,
 som erbjuder dessa möjligheter kan vara en lösning på problemet.
\end_layout

\begin_layout Abstract
Vi föreslår en lösning där det statiskt typade funktionella språket Haskell
 kompileras till JavaScript-kod.
 Detta gör det möjligt att skapa webapplikationer i en modulär och typsäker
 miljö.
\end_layout

\begin_layout Abstract
En implementation av en kompilator med stöd för kompilering av en delmängd
 av Haskell till JavaScript, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
JSHC
\end_layout

\end_inset

, presenteras som prototyplösning på problemet.
 Kompilatorn har ett grafiskt gränssnitt i form av en Emacs-lik texteditor
 som utökats med en kommandotolk, för att möjliggöra exekvering av godtyckliga
 uttryck.
 För att kompileringen ska kunna köras på klientsidan är kompilatorn skriven
 helt i JavaScript.
 
\end_layout

\begin_layout Abstract
En jämförelse mellan 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
JSHC
\end_layout

\end_inset

 och en annan JavaScript-baserad Haskellimplementation presenteras, tillsammans
 med en redogörelse för vissa oväntade komplikationer rörande Haskellspecifikati
onen.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Modern web applications are becoming more and more complex, with users expecting
 more and more automation of menial tasks such as spelling correction and
 auto completion of text.
 This leads to web applications becoming larger and more complex, which
 in turn means that they are becoming more error prone.
 One large source of errors in web applications is the absence of type safety
 in the form of static type checking in most scripting languages aimed at
 web development, such as JavaScript or PHP 
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js,type-system-dyn-web,Mikkonen07usingjavascript"

\end_inset

.
 Another problem with the growing size of web applications is the lack of
 abstraction in the form of a module system 
\begin_inset CommandInset citation
LatexCommand cite
key "Mikkonen07usingjavascript"

\end_inset

.
 One solution to this problem is providing an extra layer of abstraction
 on top of these scripts, that in turn supports a module system, and can
 be subject to static type checking.
 For example another, already existing, programming language that has these
 features can be used 
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js,HTML-in-haskell,CGI-haskell"

\end_inset

.
 
\end_layout

\begin_layout Standard
Haskell
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 is one such language, with well developed type- and module systems.
 By compiling Haskell directly to JavaScript, we use its powerful type system
 to guard against some of the errors that are hard to avoid when writing
 large and complex applications with a dynamically typed language such as
 JavaScript, while still leveraging the wide range of compatible runtime
 environments for JavaScript code.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Using Haskell for type safe web-programming is not a new concept.
 Several different approaches have been suggested; the use of Haskell to
 model HTML
\begin_inset CommandInset citation
LatexCommand cite
key "HTML-in-haskell"

\end_inset

 and using server-side Haskell applications to generate CGI
\begin_inset CommandInset citation
LatexCommand cite
key "CGI-haskell"

\end_inset

 are two examples.
 Other languages similar to Haskell have also been suggested for type safe
 web-applications, such as the functional logic language Curry
\begin_inset CommandInset citation
LatexCommand cite
key "curry-js"

\end_inset

.
 
\end_layout

\begin_layout Standard
There are several implementations of compilers from Haskell to JavaScript;
 although none of them has reached a full release stage as of the time of
 writing.
 There are three implementations of JavaScript back-ends for existing Haskell
 compilers; the Utrecht Haskell Compiler has one under development 
\begin_inset CommandInset citation
LatexCommand cite
key "uhc-javascript"

\end_inset

 which is planned for inclusion in an upcoming release, the now defunct
 
\begin_inset CommandInset citation
LatexCommand cite
key "yhc-dead"

\end_inset

 York Haskell Compiler had one, coupled with a toolkit for web content creation
 
\begin_inset CommandInset citation
LatexCommand cite
key "yhc-web-toolkit"

\end_inset

, and there is one in development as a back-end for the Glasgow Haskell
 Compiler which is in its alpha stage at the time of writing 
\begin_inset CommandInset citation
LatexCommand cite
key "ghcjs"

\end_inset

.
 
\end_layout

\begin_layout Standard
There are also at least one other attempt to implement Haskell directly
 in JavaScript, called Haskell in JavaScript, which is an online interpreter
 
\begin_inset CommandInset citation
LatexCommand cite
key "hiji"

\end_inset

.
 
\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
The purpose of this project is to implement a Haskell compiler that generates
 JavaScript code, JSHC (JavaScript Haskell Compiler).
 The compiler is to be written entirely in JavaScript, to ensure compatibility
 with most major modern browsers, and relieve users of the burden of having
 to download and install a compiler to their system.
 A JavaScript based graphical user interface with a text-editor and a code
 interpreter will also be implemented by modifying an existing JavaScript
 based text editor.
 The code interpreter will enable users to run their programs, and execute
 Haskell expressions directly in the editor, in the vein of the Glasgow
 Haskell Compiler's GHCi, or the Hugs interpreter.
 The compiler is to serve as a proof of concept for developing web applications
 in Haskell in an online environment.
 
\end_layout

\begin_layout Section
Delimitations
\begin_inset CommandInset label
LatexCommand label
name "sec:Delimitations"

\end_inset


\end_layout

\begin_layout Standard
Due to the size and complexity of the Haskell programming language, the
 JSHC implementation is limited to a small subset of Haskell containing
 the features described as beneficial to web programming above, i.e.
 static type checking, module system and lazy evaluation.
 
\end_layout

\begin_layout Standard
This differs from the initial intention with the project, which was to implement
 the full Haskell 2010 specification
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

.
 The reasons for this delimitation is discussed more in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Project-size"

\end_inset

.
\end_layout

\begin_layout Chapter
Theoretical background
\end_layout

\begin_layout Section
Introduction to Haskell
\end_layout

\begin_layout Standard
This section contains a quick introduction to Haskell for readers unfamiliar
 with or new to Haskell and/or functional languages.
 It consists of a very general overview, followed by separate sub chapters
 with details about specific features.
\end_layout

\begin_layout Standard
Haskell is a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
lazy
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
purely functional
\end_layout

\end_inset

 programming language with 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
strong static typing
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
type inference
\end_layout

\end_inset

.
 A program in Haskell consists of one or more modules, interconnected by
 their import and export specifications.
 The contents of a module is a set of top-level declarations, which can
 be, among others, function declarations, datatype declarations and typeclass
 declarations.
 Functions consist of a name, a set of arguments and an expression, that
 expresses the result of the function when applied to its arguments.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Being lazy means that an expression is only evaluated when its result is
 needed.
 Any expression whose result is not used is simply ignored.
 This enables lazy languages to feature some things that are otherwise impossibl
e, such as infinite data structures.
 Since the data structure is lazy, only the part that is needed is calculated.
 For example, a list of infinite length can be described in Haskell like
 so:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x = [1..]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This declaration assigns to the variable x an expression that calculates
 an infinite list containing all integers > 0 in rising order.
 While an expression calculating this in a strict language would never terminate
 as the set of integers > 0 is infinite, a lazy language only calculates
 the needed parts, e.g:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
take 5 x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where take is a function that returns a list consisting of the first n elements
 in a list, only needs the first 5 elements of x, so no more than 5 elements
 are computed.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Functions 
\begin_inset CommandInset label
LatexCommand label
name "sub:Functions"

\end_inset


\end_layout

\begin_layout Standard
Being a purely functional language, Haskell's functions do not have side
 effects, i.e.
 they only compute values given their arguments.
 There is no update of variables.
\end_layout

\begin_layout Standard
Another feature of purely functional languages is that functions are first-class
 objects.
 This means that functions can be passed around as arguments to other functions,
 be returned as the result of a function or created at runtime.
 This enables the creation of 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
higher order functions
\end_layout

\end_inset

, generalized functions that use other functions as arguments.
 For example, the function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
filter
\end_layout

\end_inset

 from the Haskell standard libraries takes a function, which takes one argument
 and returns a boolean, and a list.
 The function then applies the supplied function to each element in the
 list and returns a new list with all elements for which the supplied function
 returned 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A Haskell function can either be named, meaning it is declared with a name
 somewhere in the program, either as a top-level definition or as a local
 function inside a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expression, or anonymous as lambda expressions.
 Function declarations take the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
name
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
arg
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 arg
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
expression
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
name
\end_layout

\end_inset

 is any identifier starting with a lower case letter, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
arg
\end_layout

\end_inset

 1 through n is a series of zero or more arguments and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
expression
\end_layout

\end_inset

 is the expression that denotes the result of the function.
 It is possible to define functions as infix operators in the same way as
 ordinary functions, complete with custom precedence levels.
 
\end_layout

\begin_layout Standard
It is also possible to create anonymous functions, which are not bound to
 any declarations through 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
lambda expressions
\end_layout

\end_inset

.
 Lambda expressions have the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
arg
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 arg
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
expression
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
arg
\end_layout

\end_inset

 1 through n is a series of arguments and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
expression
\end_layout

\end_inset

 is the expression that denotes the result of the function.
 
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Standard
All values in Haskell have a type.
 The type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int -> Int
\end_layout

\end_inset

 represents a function which takes a value of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 and produces a result of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is possible to write a function that takes values that may be of more
 than one type.
 To achieve that, one uses 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type variables
\end_layout

\end_inset

, which are written with lower-case letters.
\end_layout

\begin_layout Standard
A function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
id :: a -> a
\end_layout

\end_inset

 (where
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
::
\end_layout

\end_inset

is read as 
\begin_inset Quotes eld
\end_inset

has type
\begin_inset Quotes erd
\end_inset

) is therefore a function that takes a value of any type and produces a
 result of the same type.
\end_layout

\begin_layout Standard
This is called a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
polymorphic type
\end_layout

\end_inset

, as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 can have a different type depending on how it is used, as the type variable
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

 can be replaced with different types.
\end_layout

\begin_layout Standard
Types can have 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type parameters
\end_layout

\end_inset

, which is necessary for collections if one wants to be able to use them
 where all values have the same type, but be able to choose that type.
\end_layout

\begin_layout Standard
A list of integers is written 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[Int]
\end_layout

\end_inset

, and a function that computes the length of a list as an 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 would have type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[a] -> Int
\end_layout

\end_inset

 as it would work regardless of the type of the values in the list.
 Note however that all the values must have the same type.
\end_layout

\begin_layout Standard
The list type is built-in.
 More generally, a type can be applied to any number of types as in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Array Int Double
\end_layout

\end_inset

 , which is an 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Array
\end_layout

\end_inset

 with indices of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Int
\end_layout

\end_inset

 and stores values of type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Type declarations
\begin_inset CommandInset label
LatexCommand label
name "sub:Type-declarations"

\end_inset


\end_layout

\begin_layout Standard
New types can be created.
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
data Tree a = Leaf | Node a (Tree a) (Tree a)
\end_layout

\end_inset

 declares a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type constructor
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 which can be applied to any type that one wants the values in the tree
 to have.
 It also declares the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
data constructor
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Leaf
\end_layout

\end_inset

 which represents an empty tree, and the data constructor 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Node
\end_layout

\end_inset

 which is used to construct a new tree given a value to store in the root
 node of the tree, and the left and right sub-tree.
\end_layout

\begin_layout Standard
The built-in lists have the special type constructor 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

, and the data constructors 
\family typewriter
[] :: 
\family default
∀
\family typewriter
a.
 [a]
\family default
 (the empty list) and 
\family typewriter
(:) :: 
\family default
∀
\family typewriter
a.
 a -> [a] -> [a]
\family default
 (creating a new list given a first element and the rest of the elements).
\end_layout

\begin_layout Subsection
Pattern matching 
\end_layout

\begin_layout Standard
Pattern matching is a conditional construct that matches an expression 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 to a set of predefined patterns paired with expressions, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

, in a fixed order.
 Matching can be done on data constructors of any arity, primitive values
 such as integers, and variables.
 Matching an expression to a variable will always succeed and, in addition,
 bind the value matched to the variable for use in the 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

.
 The first pattern to match 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 has its corresponding 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 evaluated with any variable bindings defined in the pattern0.
 Pattern matching is used in several places in Haskell, most notably function
 definitions, where they allow specifying different function behaviour depending
 on the arguments given (dividing the function into 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
clauses
\end_layout

\end_inset

), and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
Expressions in Haskell include let and where expressions which allow for
 local declarations inside expressions and functions, respectively.
\end_layout

\begin_layout Standard
Conditional expressions of the if-then-else form are supported, as well
 as pattern matching inside expressions using case expressions.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Module system
\end_layout

\begin_layout Standard
Haskell’s module system is its main method of encapsulation.
 Apart from local variables in a certain function, it is the only way to
 determine whether something is known (i.e.
 in scope) or not.
 Each module has a name, a set of imports, a set of exports and a body containin
g top-level declarations.
 The specification of these is optional, with defaults being the module
 name “Main”, the empty import set and the export set containing all top-level
 declarations.
 
\end_layout

\begin_layout Standard
By specifying exports, nothing defined in the module that is not in the
 export space can be accessed by an importing module.
 It is also allowed to specify the export of imported modules or their respectiv
e exports.
 This way, if module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

 imports module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

 and module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C
\end_layout

\end_inset

 imports module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

, it is possible for module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C
\end_layout

\end_inset

 to also have imported some definitions defined in module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

 (or even module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
B
\end_layout

\end_inset

's entire export set), depending on what module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
A
\end_layout

\end_inset

's export set is.
\end_layout

\begin_layout Standard
It is also possible for a module to specify what it will import from another
 module, either as an inclusive specification or as an exclusive specification
 (using the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hiding
\end_layout

\end_inset

 keyword).
\end_layout

\begin_layout Standard
One important feature of Haskell's module system is that unlike, for example,
 Java, it is permitted for a group of modules to import each other.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction to Compilation
\end_layout

\begin_layout Standard
This chapter is intended as an introduction to the general concepts of compilati
on for readers who have little or no experience with the inner workings
 of compilers.
 The approach to compilation described here is not the only one, and only
 describes the compilation steps used in JSHC.
 For a more general and in-depth view of compilers and compilation, 
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

 is recommended.
 
\end_layout

\begin_layout Standard
A compiler is a program that, given program code, produces new code in another
 language, the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
target language
\end_layout

\end_inset

.
 Common examples of compilers' target languages are machine code in the
 case of the GNU C Compiler, bytecode to be run in a virtual machine in
 the case of Java or another high level programming language in the case
 of the Glasgow Haskell Compiler, which can compile to C.
 
\end_layout

\begin_layout Standard
A compiler consists of two main parts; the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
front-end
\end_layout

\end_inset

 and the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
back-end
\end_layout

\end_inset

.
 The front-end takes the program code and creates an abstract representation
 of it, and the back-end takes that representation and converts it into
 the target language.
\end_layout

\begin_layout Subsection
Lexical analysis
\end_layout

\begin_layout Standard
Lexical analysis is the first part of the front-end, and is the process
 by which the compiler takes the program code in the form of an input string,
 and parses it into a list of separate tokens, 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
lexemes
\end_layout

\end_inset

, which are the smallest significant components in a programming language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 1.2.
\end_layout

\begin_layout Standard
For example, given a program in a simple language with Haskell-like syntax
 with a source code that looks like this:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fun x y = x + y
\end_layout

\end_inset


\end_layout

\begin_layout Standard
a lexer could generate a list of tokens in this vein:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[fun,x,y,=,x,+,y]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parsing
\end_layout

\begin_layout Standard
Parsing is the second part of the front-end and takes the list of lexemes
 and interprets it according to a grammar, creating a data structure containing
 an abstract representation of the code, called the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
abstract syntax tree
\end_layout

\end_inset

.
 The abstract syntax tree is a tree (or tree-like) graph with nodes representing
 the application of a certain rule in the grammar.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename adsgadgs.png
	lyxscale 50
	width 12cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graphic representation of an abstract syntax tree of a function definition
 in a simple language with Haskell- like syntax.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Semantic analysis
\end_layout

\begin_layout Standard
Semantic analysis gathers various semantic properties of the source program,
 to check for errors and to use later on in the compilation process.
 One common part of semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type checking
\end_layout

\end_inset

, where the compiler searches the abstract syntax tree for type inconsistencies.
 For example, in many languages, adding a boolean to an integer is not a
 valid expression, an error which would be caught by the type checker.
 Another common part of the semantic analysis is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
name checking
\end_layout

\end_inset

, where the compiler checks whether there are any ambiguities in variable
 names used, and whether used variables are in scope where they are used.
\end_layout

\begin_layout Standard
Other operations on the syntax tree, such as reduction of complex constructs
 into simpler, more general constructs can also be done as part of the semantic
 analysis.
 This is done to simplify the code generation process.
 Some code optimizations that are independent of the target language used
 can also be performed at this stage.
 
\end_layout

\begin_layout Subsection
Intermediate representation
\end_layout

\begin_layout Standard
After passing through the compiler front-end, the source program has been
 converted into an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
intermediate representation
\end_layout

\end_inset

, which will later be used as input for the back-end.
 The intermediate representation can take many forms, for example an abstract
 syntax tree, code in another high-level programming language, or some low-level
 code (for example three-address code)
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 1.2.
 
\end_layout

\begin_layout Subsection
Back-end
\end_layout

\begin_layout Standard
The back-end is the final part of a compiler.
 The main function of the back-end is code generation, which is the process
 of taking the intermediate representation and producing a semantically
 equivalent program in the target language
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 8.
 The back-end can also fill other functions such as performing code optimization
s that are specific to the target language.
 
\end_layout

\begin_layout Section
Compiling Haskell
\end_layout

\begin_layout Standard
In this section, we present a more detailed introduction to concepts that
 are required to understand the various steps in the compilation of Haskell.
 
\end_layout

\begin_layout Subsection
Advanced features of the type system 
\end_layout

\begin_layout Subsubsection
Quantification of types
\end_layout

\begin_layout Standard
Type variables, just as ordinary variables must be declared and used variables
 must be in scope of a declaration.
\end_layout

\begin_layout Standard
The declaration of variables is called 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
quantification
\end_layout

\end_inset

.
 A variable that is not declared is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
free
\end_layout

\end_inset

, and a variable that is declared is 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
bound
\end_layout

\end_inset

 (by the quantification).
\end_layout

\begin_layout Standard
When writing a type signature in Haskell, the quantification is implicit.
\end_layout

\begin_layout Standard
This means that a type signature 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[a] -> [a]
\end_layout

\end_inset

 is actually ∀
\family typewriter
a.
 [a] -> [a]
\family default
, where ∀ binds the type variable 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The implicit quantification of type signatures binds all type variables
 in the signature.
\end_layout

\begin_layout Standard
All type signatures written in a program and inferred by the compiler are
 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
rank-1 polymorphic types
\end_layout

\end_inset

, which means that the type given to a value begins with a quantification
 of all the type variables that occur in it, followed by the rest of the
 type which does not contain any quantifications.
 This makes the type system simpler.
\end_layout

\begin_layout Subsubsection
Kinds
\end_layout

\begin_layout Standard
Given the datatype declared in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Type-declarations"

\end_inset

, the function type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree -> Tree
\end_layout

\end_inset

 is invalid as the type 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 has a type parameter.
\end_layout

\begin_layout Standard
To detect these errors, all types and type constructors have a 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
kind
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The kind of all types is 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A function type is valid if both the argument and result type have kind
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The kind of the type constructors 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Tree
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 is 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
* -> *
\end_layout

\end_inset

, which means that they take a type and produce a type.
 They must therefore be applied to a type which is not missing any arguments
 (i.e have kind 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

), and will result in a type of kind 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Instantiation of types
\end_layout

\begin_layout Standard
When using a data constructor such as 
\family typewriter
[] :: 
\family default
∀
\family typewriter
a.[a]
\family default
, one would want to use it with lists with different element types in different
 locations.
\end_layout

\begin_layout Standard
This is achieved by replacing all bound type variables in the type with
 new type variables wherever it is used.
\end_layout

\begin_layout Standard
These type variables are now free, but will be bound after the type of the
 expression has been inferred unless they are eliminated by the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Type inference
\end_layout

\begin_layout Standard
If one makes a declaration 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
y = x : []
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset

, one will have:
\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:) :: "a -> [a] -> [a]"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[] :: [b]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x :: Int
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
b
\end_layout

\end_inset

 are free type variables.
\end_layout

\begin_layout Standard
To replace the type variables with types, one uses type inference which
 creates type constraint based upon how
\end_layout

\begin_layout Standard
the types are used.
\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
x
\end_layout

\end_inset

 is the 1st argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = Int
\end_layout

\end_inset

 is created.
\end_layout

\begin_layout Standard
Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 is the 2nd argument to 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

, the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[b] = [a]
\end_layout

\end_inset

 is created, which gives the constraint 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = b
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type inference algorithm must assign a single type to each of the free
 type variables such that all the constraints are satisfied.
\end_layout

\begin_layout Standard
If there is more than one possible assignment, then the type is called ambiguous
, and is an error, unless a default
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

,chapter 4.3.4, type can be chosen.
\end_layout

\begin_layout Standard
If there is no possible assignment, then an error will arise from the constraint
s.
\end_layout

\begin_layout Standard
In this case, there is only a single possible assignment, and the inferred
 types are:
\end_layout

\begin_layout Itemize
(:) :: Int -> [Int] -> [Int]
\end_layout

\begin_layout Itemize
[] :: [Int]
\end_layout

\begin_layout Itemize
y :: [Int]
\end_layout

\begin_layout Standard
For more details see Types and Programming Languages 
\begin_inset CommandInset citation
LatexCommand cite
key "tapl"

\end_inset

, chapter 22.
\end_layout

\begin_layout Subsection
Dependency groups
\end_layout

\begin_layout Standard
Since modules can mutually depend on each other, there can be a cycle in
 the dependencies between modules.
\end_layout

\begin_layout Standard
If a module A and a module B depends on each other by importing functions
 from the other module, one can not analyze one before the other, as the
 imported functions will be missing.
\end_layout

\begin_layout Standard
To solve this, one must analyze A and B together.
\end_layout

\begin_layout Standard
More generally, one creates a dependency group for any set of modules that
 creates a dependency cycle such as A depends on B, B depends on C, and
 C depends on A.
\end_layout

\begin_layout Standard
The dependency groups are the strongly connected components in the directed
 graph of dependencies between single modules.
\end_layout

\begin_layout Standard
After they have been computed, the resulting graph is a directed acyclic
 graph (DAG) where nodes are dependency groups, and the edges are the dependenci
es between the groups.
\end_layout

\begin_layout Standard
As there are no cycles in the dependencies between the groups, it is possible
 to traverse the groups in dependency order (a reverse topological ordering).
\end_layout

\begin_layout Standard
The Haskell standard 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 mentions dependency groups in Chapters 4.5.1, 4.5.2, and 4.6, related to different
 topics.
\end_layout

\begin_layout Standard
This concept is used in several places of the compiler.
 It is needed to describe sets of modules that depend on each other, sets
 of top-level declarations that depend on each other (even between different
 modules), and declarations in 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

/
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Standard
An example of dependencies between local definitions is:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f x = let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

even 0 = True 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

even n = odd (n-1)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

odd 0 = False
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

odd n = even (n-1)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in odd x
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
there is a cyclic dependency between the declaration of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
even
\end_layout

\end_inset

 the declaration of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
odd
\end_layout

\end_inset

.
 The same example can be applied to the case where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
even
\end_layout

\end_inset

 and odd 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
are
\end_layout

\end_inset

 top-level declarations.
 Since they mutually depend on each other, type checking needs to be performed
 on both at the same time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename Dependency groups.png
	lyxscale 15
	width 12cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example module dependency graph.
 The arrows mean 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
imports from
\end_layout

\end_inset

.
 In this example, the dependency groups are {A,B}, {C,D,E}, {G} and {F}.
 On compilation, {A,B} and {G} need to be checked first, then {C,D,E} and
 {F} last.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Method
\end_layout

\begin_layout Standard
The main part of this project was the development of the compiler itself.
 The first stage of the project was to identify and isolate subgoals and
 -problems that could be reasoned about on their own.
 Before proceeding with any actual implementation, we attempted to identify
 a theoretical solution to each of these subgoals and -problems, to facilitate
 subsequent implementation.
 Examples of such subproblems are type inference and dependency resolution.
 The next stage was to identify larger components of the project that could
 largely be implemented independently.
 Five such components were identified; lexical analyser, parser, semantic
 analyser, code generator and graphical interface.
 Responsibility for these parts was then split between group members.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implementation work was largely carried out individually, with regular meetings
 to synchronize efforts and plan ahead.
 To keep work synchronized between meetings, the git
\begin_inset CommandInset citation
LatexCommand cite
key "git"

\end_inset

 version control system was used.
\end_layout

\begin_layout Standard
To allow for compatibility with as many web browsers and JavaScript engines
 as possible, all code in JSHC is compliant with the ECMAScript standard
\begin_inset CommandInset citation
LatexCommand cite
key "ecma-262"

\end_inset

.
\end_layout

\begin_layout Standard
Early on in the project phase, it was determined that several external tools
 wold be needed to facilitate the development of JSHC.
 
\end_layout

\begin_layout Section
PEG.js
\end_layout

\begin_layout Standard
PEG.js
\begin_inset CommandInset citation
LatexCommand cite
key "peg-js"

\end_inset

 is a JavaScript implementation of parsing expression grammars, which is
 an alternative to context-free grammars and regular expressions for defining
 formal languages
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

.
 The definition of a parsing expression grammar is similar in appearance
 to that of a context-free grammar, with a few key differences.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
unordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
|
\end_layout

\end_inset

 is replaced by an 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
ordered choice
\end_layout

\end_inset

 operator 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
/
\end_layout

\end_inset

.
 This means that, instead of accepting a match on any rule in a production,
 a parsing expression grammar always accepts the first rule matched.
 This means that parsing expression grammars are inherently unambiguous.
 If there are two possible matches to a rule, simply match the one that
 occurred first.
 
\end_layout

\begin_layout Standard
Parsing expression grammars also have several operators similar to those
 used in regular expressions.
 There are the repetition operators 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

 which matches zero or more repetitions of a rule, and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 which matches one or more repetitions of a rule.
 There is also the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
?
\end_layout

\end_inset

 operator which either matches a rule and returns it, or does not match
 it and returns an empty match.
 Just as with the ordered choice, these operators take a greedy approach,
 i.e.
 they always consume the maximum amount of input possible.
 
\end_layout

\begin_layout Standard
Lastly, parsing expression grammars feature the syntactic predicates 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

.
 These match their paired rule, and either fail or succeed without advancing
 the parser position.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
&
\end_layout

\end_inset

 returns an empty match if the match is successful and fails otherwise,
 while 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
!
\end_layout

\end_inset

 returns an empty match if the match fails and succeeds otherwise.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
PEG.js generates a Packrat
\begin_inset CommandInset citation
LatexCommand cite
key "ford-packrat"

\end_inset

 parser, i.e.
 a top-down recursive descent parser with backtracking.
 To avoid a worst-case scenario of exponential runtime, Packrat parsers
 store intermediate results in a table, sacrificing storage space for guaranteed
 linear-time complexity.
 
\end_layout

\begin_layout Standard
PEG.js was chosen for this project due to the suitability of parsing expression
 grammars for writing lexical analysers 
\begin_inset CommandInset citation
LatexCommand cite
key "parsing-expression-grammars"

\end_inset

 in a concise and intuitive way, as well as for the efficiency of Packrat
 parsers.
 
\end_layout

\begin_layout Section
Jison
\end_layout

\begin_layout Standard
Jison
\begin_inset CommandInset citation
LatexCommand cite
key "jison"

\end_inset

 is a parser generator for generating JavaScript parsers.
 It takes a context-free grammar in the same format as the input files to
 Bison, apart for parser actions, which are defined in the implementation
 language, which is JavaScript for Jison and C for Bison.
 Just like Bison, the parser generated by Jison is LALR(1) by default
\begin_inset CommandInset citation
LatexCommand cite
key "jison,bison-manual"

\end_inset

, which is the option used for the parser in JSHC.
 
\end_layout

\begin_layout Standard
Jison was chosen mainly because of the familiarity and extensive documentation
 of the Bison notation and functionality, as well as for its powerful constructs
 for handling user-defined error handling, something which is essential
 to a Haskell parser 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 10.3.
 The speed and compact size of LALR parsers were also taken into account,
 but not critical for the choice.
 
\end_layout

\begin_layout Section
Ymacs
\end_layout

\begin_layout Standard
As a graphical interface to JSHC, a JavaScript-based Emacs-like text editor
 named Ymacs
\begin_inset CommandInset citation
LatexCommand cite
key "ymacs"

\end_inset

 was chosen.
 The main reasons for this choice were that Ymacs is easily extendable and
 is fully compatible with three of the most widely used web browsers (Mozilla
 Firefox, Google Chrome and Apple Safari
\begin_inset CommandInset citation
LatexCommand cite
key "browser-statistics"

\end_inset

).
 Also, Emacs is a popular coding environments among Haskell programmers
\begin_inset CommandInset citation
LatexCommand cite
key "state-of-haskell"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Ymacs interface design centers around the two central concepts of 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
buffers
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
modes
\end_layout

\end_inset

.
 The word buffer refers to two different entities in the Ymacs program;
 the data structure which stores entered text coupled with the functions
 managing its manipulation, and the text field which is presented a user.
 These two denotations will be used interchangeably, as it should be clear
 from context which denotation is intended.
 While the default Ymacs view contains a single buffer, buffers can be split,
 by creating a new buffer sharing the same screen space.
 Each buffer has a mode, which determines the behaviour of the buffer.
 Modes determine what hot key commands are available, how text is displayed
 etc.
 Due to the transparent nature of JavaScript programs (i.e.
 all code inside a JavaScript application shares the same global namespace),
 modes can be used to completely redefine the behavior of a buffer without
 changing any of the Ymacs source code.
 
\end_layout

\begin_layout Chapter
Result
\end_layout

\begin_layout Standard
The result of this project is a Haskell compiler written in JavaScript,
 producing code in JavaScript.
 An interface with a text editor and interpreter terminal has been implemented
 by integrating an existing editor with the compiler.
\end_layout

\begin_layout Standard
The project web page is 
\begin_inset CommandInset href
LatexCommand href
target "http://jshc.insella.se/"

\end_inset

, where one can try out the JSHC interface and also download source code
 (which is distributed under the permissive MIT license
\begin_inset CommandInset citation
LatexCommand cite
key "MIT-license"

\end_inset

).
 The source code contains a copy of Ymacs which is distributed under the
 permissive BSD-3 license
\begin_inset CommandInset citation
LatexCommand cite
key "BSD-3-license"

\end_inset

.
\end_layout

\begin_layout Section
Supported language features
\begin_inset CommandInset label
LatexCommand label
name "sec:Supported-language-features"

\end_inset


\end_layout

\begin_layout Standard
This section describes informally the subset of Haskell features implemented
 in JSHC.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig: shorthand syntax"

\end_inset

 contains a simplified syntax reference for the subset of Haskell supported.
 Note that some accuracy has been sacrificed in favour of simplicity in
 that figure.
 For brevity, module system syntax has been omitted.
 For a full formal syntax reference, see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Context-free-syntax"

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
JSHC supports a subset of the Haskell module system, with exception to qualifyin
g and renaming imports.
 It also lacks support for many cases of mutually recursive modules.
\end_layout

\begin_layout Standard
Polymorphic type inference, without overloading through type classes, is
 supported, as well as lazy evaluation of expressions.
 
\end_layout

\begin_layout Standard
Top level declarations supported are non-strict abstract datatypes, fixity
 declarations, top-level function declarations (including user-defined operators
) and type signatures.
 Local declarations are supported in let and where expressions.
\end_layout

\begin_layout Standard
Expressions supported are lambda abstractions, conditional expressions,
 case expressions, tuples, lists, integer literals and function, operator
 and data constructor applications.
 
\end_layout

\begin_layout Standard
Pattern matching in case-expressions and function definitions, using patterns
 for data constructors, tuples, integer literals, variable bindings and
 wildcards is supported.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
top-decl → data <con> [ <var>+ ] [ = <constructor>+ 
\end_layout

\end_inset

(separator: "|")
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
 ] 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <declaration> 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constructor → <con> <type>+
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
type → <con> | <var> 
\end_layout

\end_inset

(separator: "->")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
declaration → <function> | <type-signature> | <fixity-decl>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
type-signature → <var>+ :: <type> 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fixity-decl → <fixity> <integer> <op>+ 
\end_layout

\end_inset

(separator: ",")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fixity → infixl | infixr | infix
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
function → <fun-lhs> = <exp> [where { <declaration>+ } ] 
\end_layout

\end_inset

(separator: ";")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fun-lhs → <var> <pattern>+ | <pattern> <opid> <pattern>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp → 
\backslash
 <pattern>+ -> <exp>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| let { <declaration+> } in <exp> 
\end_layout

\end_inset

(separator: ";")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| if <exp> [;] then <exp> [;] else <exp>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| case <exp> of { <alternative>+ } 
\end_layout

\end_inset

(separator: ";")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <exp>+
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <integer>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| ( <exp> , <exp>+ ) 
\end_layout

\end_inset

(separator: ",")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| [ <exp>+ ] 
\end_layout

\end_inset

(separator: ",")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| ( <exp> )
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <exp> <op> <exp>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <var>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <con>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alternative → <pattern> -> <exp> [where { <declaration>+ } ]
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(separator: ";")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pattern → <con> [ <pattern>+ ] 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <integer>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| _
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| <var>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| ( <pattern> )
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| ( <pattern> , <pattern>+ ) 
\end_layout

\end_inset

(separator: ",")
\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
integer → any integer literal
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
var → any variable identifier
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| ( <op> ) 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
op → any symbol identifier 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| `<var>` 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
con → any constructor identifier
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Simplified syntax reference for the subset of Haskell supported by JSHC.
 
\begin_inset Newline newline
\end_inset

Arrows denote the start of a rule, | denotes alternative productions of
 a rule.
 Items surrounded by angular brackets are references to a rule in the grammar
 and items contained in square brackets are optional.
 All other items represent strings.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig: shorthand syntax"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
User Interface
\end_layout

\begin_layout Standard
The interface is a modified Ymacs environment.
\end_layout

\begin_layout Standard
To modify the behaviour of Ymacs to make it suitable as a development environmen
t for JSHC, several modifications has been done to the default environment.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename JSHCscreen_smaller.png
	lyxscale 20
	width 16.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Screen capture of the Ymacs interface and JSHC interpreter as viewed in
 a web browser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An interface for using the compiler has been created.
 It uses Ymacs to allow a user to write modules and then load them in an
 interpreter that uses the compiler.
\end_layout

\begin_layout Standard
The interface provides two initial buffers: a buffer named 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
keybindings.txt
\end_layout

\end_inset

 containing the general keybindings which are available regardless of mode,
 and a buffer called 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Main.hs
\end_layout

\end_inset

, which is empty.
 The 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Main.hs
\end_layout

\end_inset

 buffer, and any new buffers that has a name ending with 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.hs
\end_layout

\end_inset

 will have the command 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C-x i
\end_layout

\end_inset

 available to show the interpreter terminal in a new frame by splitting
 the current frame (unless already visible, in which case the focus is just
 changed).
\end_layout

\begin_layout Standard
There will also be an attempt to load the Haskell file with the same name,
 and if found in any of the paths provided, the file contents will be written
 into the buffer.
\end_layout

\begin_layout Standard
The interpreter terminal supports a subset of the GHCi commands (table 
\begin_inset CommandInset ref
LatexCommand ref
reference "Interpreter-commands"

\end_inset

), allows evaluation of Haskell expressions, and also includes a command
 for evaluation of JavaScript expressions.
\end_layout

\begin_layout Standard
It only allows insertion/deletion of a character/selection on the user input
 on the last line.
\end_layout

\begin_layout Standard
There is auto-completion of commands using 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
TAB
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="3.6in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
command
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:help
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints available commands
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:kind
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes any number of type constructors and prints the kind of each
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:load
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a number of module names of modules to load.
 Will find all dependencies and recompile modules as necessary.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the possible arguments to :show
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a Haskell expression which will be compiled.
 If it has no errors, the type of the expression will be printed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:js
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Takes a JavaScript expression and evaluates it.
 If it has no errors, the result will be printed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show path
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the URLs which will be used when loading Haskell modules.
\end_layout

\begin_layout Plain Layout
The default paths are 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hslib/
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
hsusr/
\end_layout

\end_inset

 from the root of the source distribution.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the generated JavaScript code of all loaded Haskell modules.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
:show modules
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints the names of the currently loaded modules.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Interpreter commands
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Interpreter-commands"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:implementation"

\end_inset

 shows how the interface (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:User-Interface"

\end_inset

) uses the compiler.
\end_layout

\begin_layout Standard
Given a set of modules to load (the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
target
\end_layout

\end_inset

 set), the compiler will load (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Loading-modules"

\end_inset

) them resulting in the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
loaded
\end_layout

\end_inset

 set, which is set of all required modules unless there was an error.
\end_layout

\begin_layout Standard
The compiler will then compute the dependency groups of the loaded set,
 and traverse the groups in dependency order (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Checking-module-groups"

\end_inset

).
\end_layout

\begin_layout Standard
The compiler will then for each module, translate the abstract syntax tree
 (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Simplify"

\end_inset

) to the intermediate representation, and then generate (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:back-end"

\end_inset

) JavaScript code.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename gen-prog-structure.png
	lyxscale 20
	width 16.5cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:implementation"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Flow of information in the implementation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:User-Interface"

\end_inset

User Interface
\end_layout

\begin_layout Standard
Commands in Ymacs are added using modes.
 A mode contains a key map to be checked before the default key map, and
 a Ymacs tokenizer that handles coloring.
\end_layout

\begin_layout Subsubsection
The Haskell mode
\end_layout

\begin_layout Standard
A Haskell mode has been created for buffers containing Haskell code.
\end_layout

\begin_layout Standard
The command 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C-x i
\end_layout

\end_inset

 calls a global function that searches for the interpreter buffer.
 There can only be a single interpreter buffer, so a new interpreter buffer
 is only created if one does not already exist.
\end_layout

\begin_layout Subsubsection
The Interpreter terminal
\end_layout

\begin_layout Standard
The terminal is an ordinary buffer modified in several ways, together with
 a mode that traps input from the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ENTER
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
TAB
\end_layout

\end_inset

 keys and assigns custom behaviour to them.
\end_layout

\begin_layout Standard
Functions to insert and delete text are wrapped into new functions that
 will be called instead, to prevent inserting text anywhere in the buffer.
\end_layout

\begin_layout Standard
The buffer contains a reference to the interpreter object, and can therefore
 call the interpreter methods to execute commands.
 The buffer also adds a callback to the interpreter so that error messages
 from the commands are not return values from the interpreter, but instead
 calls to functions that add output to the buffer.
 This allows output to be written to the buffer while the interpreter is
 working, and not all at once at the end.
\end_layout

\begin_layout Subsubsection
Setting modes automatically
\end_layout

\begin_layout Standard
Since no mode is automatically set for new buffers, the method that handles
 creation of new Ymacs buffers has been wrapped in a new method that sets
 a mode for the buffer based upon what the extension of the name of the
 buffer is.
 The implementation is similar for opening an existing module.
\end_layout

\begin_layout Subsubsection
Interpreter
\end_layout

\begin_layout Standard
The interpreter contains the implementation of all commands.
\end_layout

\begin_layout Standard
It contains an instance of the compiler which it uses to load code, look
 up names, and compile expressions.
\end_layout

\begin_layout Standard
Compiler output is sent to the interpreter via callbacks, so the compiler
 does not know about the interpreter.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Loading-modules"

\end_inset

Loading modules
\end_layout

\begin_layout Standard
The loading begins with the module names of a set of modules to load, and
 will search for them in a virtual file system (mapping from module names
 to unparsed strings), a list of URLs (which can refer to files using the
 file:// or http:// protocols).
 Each found module must be parsed in order to find out which modules it
 depends upon.
 Those modules (unless already loaded) must then be found and parsed as
 well.
 This process continues until no more modules are needed, and the minimal
 set of modules that satisfies all the module dependencies has been found.
 In case a module can not be found or there is a parse error, this process
 will still continue and try to satisfy more dependencies and see if there
 are more missing modules or parse errors.
\end_layout

\begin_layout Subsubsection
Lexical analysis
\end_layout

\begin_layout Standard
The lexical analysis in JSHC is performed in several steps.
 
\end_layout

\begin_layout Standard
While lexical analysis is often done by having the parser request a token
 from the lexical analyzer, match that token against a rule, request another
 and so on
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 3.1, the layout-dependent syntax of Haskell requires a different
 approach.
 First, the input (i.e.
 the Haskell source code, including whitespace and comments) is parsed into
 an array of tokens in one go.
 This is done by using a parser built using PEG.js that was fed a translation
 (into PEG.js-readable form) of the lexical program structure described in
 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 2.2.
 Second, the generated array of tokens is run through a function that adds
 indentation information to the array in the form of special indentation
 tokens, and annotates tokens with position information.
 Whitespace and comments are discarded after being used to calculate position
 information, as they are no longer needed.
 Lastly, this array is fed into an object which interfaces with the parser
 according to the Jison/Bison style API
\begin_inset CommandInset citation
LatexCommand cite
key "dragon-book"

\end_inset

, chapter 3.1, using the indentation information to generate tokens to convert
 Haskell's layout-dependent syntax into a context-free one.
 
\end_layout

\begin_layout Standard
As an example, the code: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f = let
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x = 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

y = 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

in x + y
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
generates, after the first and second stages this array of tokens (token
 representation rewritten for readability):
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[{1},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

let
\begin_inset Quotes erd
\end_inset

,{3},ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,ID,
\begin_inset Quotes erd
\end_inset

=
\begin_inset Quotes erd
\end_inset

,INT,<3>,
\begin_inset Quotes erd
\end_inset

in
\begin_inset Quotes erd
\end_inset

,ID,OP,ID]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where the tokens 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{n}
\end_layout

\end_inset

 designate the start of a block after a newline and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
<n>
\end_layout

\end_inset

 representing a newline where a new block should not begin.
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
n
\end_layout

\end_inset

 represents the indentation of the starting column of the first token on
 the new line.
 Given this array as input, the last stage of the lexer will deliver to
 the parser tokens representing a context-free version of the code which,
 converted back into Haskell source code, would look like this:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{f = let {x = 1;y = 2} in x + y}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parsing
\end_layout

\begin_layout Standard
The context-free syntax is parsed by a parser implemented using the JISON
 parser generator 
\begin_inset CommandInset citation
LatexCommand cite
key "jison"

\end_inset

.
 The parser and the last step of the lexical analysis work in concert, meaning
 that the lexical analyzer does not process and return all tokens in one
 go, but only sends the parser tokens when asked to.
 To handle certain features of the layout dependent syntax of Haskell, that
 cannot be handled by the lexical analyzer alone, the parser will inform
 the lexical analyzer of any such parse errors, so that the lexer can react
 and send new tokens that solve the problem (c.f.
 the description of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
parse-error
\end_layout

\end_inset

 function in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 10.3).
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Checking-module-groups"

\end_inset

Checking module groups
\end_layout

\begin_layout Standard
For each dependency group of modules checked in dependency order, the compiler
 does the following:
\end_layout

\begin_layout Standard
If some modules are already compiled, they will only be compiled if not
 all of the modules within the same group have previously been compiled.
\end_layout

\begin_layout Standard
For each module, compute the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
tspace
\end_layout

\end_inset

 (the set of declared top-level names in the module), and adding fixity
 information to this name so that it can easily be found later on.
\end_layout

\begin_layout Standard
Resolve the exports (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Export-check"

\end_inset

), which results in the 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
espace
\end_layout

\end_inset

 (the set of exported names) being known for each module in the group.
\end_layout

\begin_layout Standard
For each module, check usage of names (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Name-check"

\end_inset

).
\end_layout

\begin_layout Standard
For each module, resolve fixity of operators (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Fixity-Resolution"

\end_inset

).
\end_layout

\begin_layout Standard
Then dependency groups are produced for the top-level declarations of all
 modules in the group.
 The groups are then type checked in dependency order.
\end_layout

\begin_layout Itemize
Export check: Computes the export space of each module
\end_layout

\begin_layout Itemize
Name check: Checks if names are in scope, and qualifies names referring
 to top-level declarations
\end_layout

\begin_layout Itemize
Fixity resolution: Replace all lists of infix applications with operator
 application
\end_layout

\begin_layout Itemize
Type check: Compute types and kinds.
\end_layout

\begin_layout Subsubsection
Finding and traversing dependency groups
\end_layout

\begin_layout Standard
The implementation for handling dependency groups takes a set of entries,
 where each entry provides a set of names, depends on a set of names, and
 contains a set of items, such as modules or declarations.
\end_layout

\begin_layout Standard
These entries will have to be created from the declarations or modules that
 one will want to create dependency groups for.
\end_layout

\begin_layout Standard
The entries are nodes in a graph where the minimal number of entries are
 merged such that there are no longer any cycles in the graph.
\end_layout

\begin_layout Paragraph
Condensing the graph
\end_layout

\begin_layout Standard
Given a directed graph where the edges represents dependencies, it merges
 the minimal amount of nodes to create a directed acyclic graph.
 This is done by finding the connected components in the graph and merging
 all the nodes in each connected component into a single node.
\end_layout

\begin_layout Standard
The algorithm is a depth-first search through the graph which keeps track
 of the current path and merges all the nodes in a cycle whenever one is
 found.
\end_layout

\begin_layout Paragraph
Dependency order traversal
\end_layout

\begin_layout Standard
To traverse the graph in dependency order, an opposite edge is added for
 each edge so that each group not only knows what it depends upon, but also
 which groups depends upon it.
 Each group keeps track of the number of remaining groups that it depends
 on, and for each group that is checked, this number is decreased for all
 groups that depends on it (which are exactly the set of groups accessible
 via the added edges).
 The traversal keeps track of a ready set and waiting set of groups.
 Whenever the number of remaining unchecked dependencies reaches 0, the
 group is moved to the ready set.
\end_layout

\begin_layout Standard
Unless there are missing dependencies (or there are groups which are currently
 being checked), the ready set will never be empty while the waiting set
 is not.
\end_layout

\begin_layout Standard
A group is checked by removing it from the ready set, check it, and then
 inform the traversal algorithm that the group is checked.
\end_layout

\begin_layout Standard
When both sets are empty, the traversal is complete.
\end_layout

\begin_layout Standard
Concurrency is possible, since any number of groups could be taken out from
 the ready set to be checked at the same time.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Export-check"

\end_inset

Export check
\end_layout

\begin_layout Standard
The implementation gives an error if modules in the same group have a list
 of exports, as this is currently not supported.
 If the modules do not have a list of exports, all top-level declarations
 are exported, which is easy to handle, and is only what is currently supported.
 If there is only a single module in a group, then the export list may exist
 and the exported names are resolved by looking at all top-level declarations
 and imports.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Name-check"

\end_inset

Name check
\end_layout

\begin_layout Standard
This is applied separately on each module in a group.
\end_layout

\begin_layout Standard
Errors is given for missing and ambiguous names.
 Otherwise the name will be qualified with the qualification of what it
 refers to so that the definition can easily be found later on when it is
 non-local.
 The definition needs to be found later on when fixity and type information
 is required.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Fixity-Resolution"

\end_inset

Fixity Resolution
\end_layout

\begin_layout Standard
Fixity resolution is applied separately on each module in a group.
 It is the procedure which, given information on each operator's fixity
 and precedence, calculates in which order the operators in an infix expression
 are to be applied.
 This information is then used to convert the infix expressions into ordinary
 prefix function applications.
 
\end_layout

\begin_layout Standard
For example, the expression 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
2 + 3 * 10
\end_layout

\end_inset

 could evaluate to 32 or 50, depending on the fixity and precedence of the
 operators 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

.
 The algorithm looks up the fixity information of the operators, and finds
 out that they are both left fix operators with precedences of 6 and 7 respectiv
ely.
 Since 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset

 has the higher precedence, it should be applied before 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

, resulting in the application expression 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(+) 2 ((*) 3 10)
\end_layout

\end_inset

, which evaluates to 32, as expected by anyone familiar with the operators'
 precedence in ordinary arithmetics.
 
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Type-checking"

\end_inset

Type checking
\end_layout

\begin_layout Standard
The monomorphism restriction (
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 4.5.5) is not implemented.
\end_layout

\begin_layout Standard
Since type classes are not implemented, the type system only implements
 the parametric polymorphism.
\end_layout

\begin_layout Standard
Type checking is applied on dependency groups over all declarations from
 all modules in the group, since one can not check the top-level declarations
 of a single module in dependency order as they may depend on types from
 top-declarations in other modules within the same group.
\end_layout

\begin_layout Standard
While type checking, the algorithm keeps track of local names and type variables
, and also the constraints using a map from the type variables to types
 to which they are constrained.
\end_layout

\begin_layout Paragraph
The constraint map
\end_layout

\begin_layout Standard
The constraint map maps type variables (LHS) to types (RHS).
\end_layout

\begin_layout Standard
It simply represents the types that type variables are constrained to.
\end_layout

\begin_layout Standard
Type variables are only given a type if they are constrained, so all new
 type variables will not be in the map until a constraint is placed upon
 them.
\end_layout

\begin_layout Standard
Type variables on the LHS may not occur in their corresponding RHS as this
 would create an infinite type, and may only occur in the RHS of other variables
 if the other RHSs are such that there is no infinite type.
 This invariant is maintained when new constrained are inserted.
\end_layout

\begin_layout Standard
The reason for using a constraint map is that type errors are discovered
 as soon as possible, so a type error in a sub-expression will be given
 for the sub-expression instead of the expression as a whole if the constraints
 were just gathered and then checked after computing all of them, which
 is the usual description of solving the constraints (see chapter 22 in
\begin_inset CommandInset citation
LatexCommand cite
key "tapl"

\end_inset

).
\end_layout

\begin_layout Paragraph
Adding constraints
\end_layout

\begin_layout Standard
Function constraints of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a -> b = c -> d
\end_layout

\end_inset

 will be split into two separate constraints 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
a = c
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
b = d
\end_layout

\end_inset

, which will each cause elimination of a type variable as the constraint
 specifies that two types variables are equal.
\end_layout

\begin_layout Paragraph
Checking a group of declared names
\end_layout

\begin_layout Standard
Each declared name in a group is given a type variable.
 As the declarations are checked, the type variables for the names will
 be constrained depending on what the declaration contains.
 After all declarations in the group have been checked, all free type variables
 occurring in the types bound to the type variables of each declared name
 are quantified since they only occur inside the declarations.
\end_layout

\begin_layout Paragraph
Checking declarations
\end_layout

\begin_layout Standard
It is necessary to use dependency groups and check in dependency group order
 to give the correct type, instead of checking all of the declarations as
 a single group, because of the monomorphism restriction.
 In a declaration such as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
f = (+)
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset

 is supposed to be non-polymorphic, which means that the polymorphic type
 must be simplified before checking other declarations that depend upon
 it.
\end_layout

\begin_layout Standard
However, the monomorphism restriction is currently not implemented.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Simplify"

\end_inset

Translation to the intermediate representation
\end_layout

\begin_layout Standard
This step translates the abstract syntax tree to the intermediate representation
 used by the back-end, see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:B.2Intermediate-representation"

\end_inset

 for details.
 Several constructs are reduced to other, simpler and more general, constructs
 to create a kernel, which is a small subset of Haskell.
 The constructs that can be reduced in this way can be seen as syntactic
 sugar of the kernel
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

, chapter 1.2.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Conditional expressions are simplified by converting 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
if
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e1
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
then
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e2
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
else
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e3
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
to a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expression of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e1
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
of
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{True ->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e2
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
;
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
False -> 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e3
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 expressions both bind expressions to local variables, something which is
 possible to express with 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 expressions.
 Thus, expressions of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
let
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
decls
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
in
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
where
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
decls
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
decls
\end_layout

\end_inset

 is a set of declarations of the form 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
are converted to expressions of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case (
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) of 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
 ->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
 }
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pattern matching in function definitions is converted by merging function
 clauses of the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 ...
 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 is the function identifier, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\end_layout

\end_inset

 is any argument patterns and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 is the right hand side of each clause, into one single clause of the form
 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
= case (
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) of {
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
; ...
 ;
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pats
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 through 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 are variable pattern matches created to preserve function arity.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Function declarations with arguments are converted into a binding from the
 function name to a sequence of lambda expressions corresponding to the
 arity of the function.
 Functions of the form: 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

= 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

 is the function identifier, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 through 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 are function arguments and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 is the right hand side of the function, are converted into functions of
 the form 
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id 
\end_layout

\end_inset

 = 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
\paragraph_spacing onehalf
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntactic sugar for lists, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[ 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
: : :
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
 ]
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 through 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 are arbitrary expressions, is converted into applications of the list construct
or (cons), resulting in expressions of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
((:)
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
( 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
:::
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(:)
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[])))
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Note that the cons operator is written in prefix notation, as an ordinary
 data constructor, instead of as an infix constructor, as is normally done
 when writing source code.
 This is because at this stage operator applications have already been removed
 from the language by the fixity resolution algorithm described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Fixity-Resolution"

\end_inset

.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:back-end"

\end_inset

Compiler back-end
\end_layout

\begin_layout Standard
JSHC's back-end takes an intermediate representation in the form of an abstract
 syntax tree and compiles it to JavaScript code.
 
\end_layout

\begin_layout Subsubsection
Internal libraries
\begin_inset CommandInset label
LatexCommand label
name "sub:Internal-libraries"

\end_inset


\end_layout

\begin_layout Standard
To implement some basic functionality of the generated code which cannot
 be efficiently defined in Haskell (or is needed for our implementation
 to operate at all), an internal JavaScript library was developed.
 This library contains functions for handling integer arithmetics, arithmetic
 comparisons, lazy evaluation and pattern matching.
 
\end_layout

\begin_layout Standard
Since JavaScript does not have integers built in, the arithmetics for the
 Haskell integer types requires internal libraries that manage integer behaviour
, such as overflow.
\end_layout

\begin_layout Standard
Laziness is implemented by creating a JavaScript object called 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

.
 When a lazy expression is created, the strict JavaScript expression is
 wrapped in a JavaScript function (without parameters), which is subsequently
 wrapped in a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 object.
 When the result is needed, a method of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 object is called, which calls the function and assigns the value to a variable.
 Whenever the result is needed again, the value of the variable is returned.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pattern matching is handled by an internal function, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
match
\end_layout

\end_inset

, that is sent an expression, 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

, and an array of pairs 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pattern
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
,
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pattern
\end_layout

\end_inset

 is the pattern to match the result of 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 to, and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 is a function that takes any bindings made in 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pattern
\end_layout

\end_inset

 as arguments, and returns the right hand side expression of that particular
 pattern match alternative.
 The pairs are then matched sequentially, one at a time until a match is
 found or there are no more alternatives to match.
 When a match is found, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
match
\end_layout

\end_inset

 evaluates 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 with its bindings as arguments.
\end_layout

\begin_layout Standard
Matching of a pattern against an expression is done lazily and recursively.
 
\end_layout

\begin_layout Standard
Constructor patterns first evaluate 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

, then match the name and arity of the constructor in 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

, then recursively match all the constructor's arguments from left to right.
 Tuple patterns work in the same way as constructor patterns, but without
 the comparison of constructor names, as there are none.
\end_layout

\begin_layout Standard
Integer patterns first evaluate 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 and then return a positive match if the value of 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 is equal to the pattern.
\end_layout

\begin_layout Standard
Wildcard and variable patterns both match 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 without evaluating it, with the difference that variable patterns also
 add it to the set of bindings.
 
\end_layout

\begin_layout Standard
When there are no sub-patterns left to match, if the match has succeeded
 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 can be executed, if the match fails the matching continues on the next
 alternative.
\end_layout

\begin_layout Subsubsection
Code generation
\end_layout

\begin_layout Standard
The code generation step generates JavaScript code as a JavaScript string
 representing the compiled modules.
 This code can then be accessed and executed by any JavaScript interpreter.
 For the generated code to be as easy to use in an external application
 as possible, the code generation preserves the names of as many identifiers
 as possible.
 This also allows for easier debugging of the generated code.
 Below follows a walkthrough of how components of the intermediate representatio
n (Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:B.2Intermediate-representation"

\end_inset

) are translated to JavaScript.
 If not defined in the text, names in italics refer to the meta variable
 of an item name in the description of the corresponding node in the intermediat
e representation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "sec:B.2Intermediate-representation"

\end_inset

.
\end_layout

\begin_layout Paragraph
Modules and declarations
\end_layout

\begin_layout Standard
Modules are represented as JavaScript objects of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset

 is a module prefix specified by the user.
 Both 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 can include 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.
\end_layout

\end_inset

 , which will create a nested object.
 E.g.
 substituting 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset

 for 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
JSHC.mod
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 for 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Data.List
\end_layout

\end_inset

 will create the JavaScript object 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
JSHC.mod.Data.List
\end_layout

\end_inset

.
 Following paragraphs will use 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 to refer to the concatenation
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
prefix
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
.
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Function declarations have the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset

 is an arbitrary variable identifier and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 is an arbitrary expression, and are compiled to JavaScript assignment statement
s of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f'
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp'
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f'
\end_layout

\end_inset

 is the compilation of the identifier 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp'
\end_layout

\end_inset

 the compilation of the expression 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Data declarations contain constructors of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
C
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
t
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
 
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
t
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 which are all compiled into curried functions in the same way as lambda
 expressions, as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:code-gen-Expressions"

\end_inset

.
 The type constructor is used to create a JavaScript object, which is used
 as the JavaScript constructor called by its data constructors when they
 have been applied to all arguments.
 The type variables and data constructor type arguments are not used.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:code-gen-Expressions"

\end_inset

Expressions
\end_layout

\begin_layout Standard
Lambda expressions are compiled from a form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\end_layout

\end_inset

 represents arbitrary patterns, into a JavaScript function representing
 its curried 
\begin_inset CommandInset citation
LatexCommand cite
key "Hudak:1989:CEA:72551.72554"

\end_inset

 form:
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
function ( 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) { return function (
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{2}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) {return 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
function (
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) { return
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}}
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tuple expressions are compiled into JavaScript objects containing an array
 with all expressions.
 Expressions of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

 are compiled into JavaScript constructor calls with the argument 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
]
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Application of data constructors and functions are compiled in the same
 way; JavaScript's ordinary function application is used.
 Expressions of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset

 is an arbitrary function or data constructor expression and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\end_layout

\end_inset

 represents its arguments, are compiled into curried JavaScript applications:
 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
This approach, coupled with how compilation of lambda expressions is handled,
 allows for partial application of functions.
 An application of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
a
\begin_inset Formula $_{\text{n-2}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

 will return a JavaScript expression of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
function (
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n-1}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) {return 
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
function (
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
) { return
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
}}
\end_layout

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case expressions are compiled to a call to an internal function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
match
\end_layout

\end_inset

, where the argument is an expression to match and an array of alternatives.
 Expressions of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
case
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
of
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
alts
\end_layout

\end_inset

 are compiled into 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
match(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
alts
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

.
 The workings of match are explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Internal-libraries"

\end_inset

.
\end_layout

\begin_layout Standard
Alternatives are compiled into pairs of patterns and right hand sides.
 Expressions of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pat
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 are compiled into anonymous JavaScript objects 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
{p:
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
pat
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, f: function(
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
b
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
b
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

 { return
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
} }
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
b
\end_layout

\end_inset

 represents expressions bound in the pattern and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
f
\end_layout

\end_inset

 is a function that evaluates 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
exp
\end_layout

\end_inset

 with the bound expressions as arguments.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Patterns and pattern matching
\end_layout

\begin_layout Standard
Constructor patterns are compiled into JavaScript objects with one member
 containing the constructor identifier as a string, and one member containing
 an array with the constructor's arguments.
 Patterns of the form 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
D
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

, where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
D
\end_layout

\end_inset

 is an arbitrary data constructor and 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\end_layout

\end_inset

 represents arbitrary patterns, compile into a call to a JavaScript constructor
 with the string representing 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
D
\end_layout

\end_inset

 and the array containing 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Tuple patterns are compiled into JavaScript objects containing an array
 with all tuple members.
 Patterns of the form 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
(
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
)
\end_layout

\end_inset

 are compiled into JavaScript constructor calls with the argument 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
[
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{1}}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
, ...
 ,
\end_layout

\end_inset

 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
p
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Wildcard patterns are compiled into a JavaScript object representing wildcard
 patterns.
\end_layout

\begin_layout Standard
Integer patterns are compiled into JavaScript objects containing an integer
 literal.
\end_layout

\begin_layout Standard
Variable patterns are compiled into an object containing the variable identifier
 as a string.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pattern matching is compiled into calls to an internal function 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
match
\end_layout

\end_inset

, described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Internal-libraries"

\end_inset

, that emulates the behaviour of Haskell's pattern matching in JavaScript.
 
\end_layout

\begin_layout Paragraph
Identifiers and literals
\end_layout

\begin_layout Standard
Variable identifiers can be compiled in two ways.
 If they are qualified, they are declared at the top-level and thus compiled
 as members of the object representing the module, using JavaScript's associativ
e array notation to enable members with non-alphanumeric characters as identifie
rs.
 A variable identifier 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

, which is a reference to an identifier declared at the top level in any
 module, is compiled into JavaScript: 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
modid
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
["
\end_layout

\end_inset


\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id'
\end_layout

\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
"]
\end_layout

\end_inset

 where 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id'
\end_layout

\end_inset

 is the unqualified identifier for 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
id
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
If a variable identifier is not qualified, it is declared locally, and is
 compiled as a JavaScript string.
 
\end_layout

\begin_layout Standard
Data constructor identifiers can only refer to top-level declarations, and
 will always be compiled the same way as top-level variable identifiers.
\end_layout

\begin_layout Standard
Since the foreign function interface as described in the Haskell report
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 is currently not implemented, any identifier located in the module 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
JSHC.Internal
\end_layout

\end_inset

 is a treated as reference to a JavaScript function in the internal libraries.
 These internal functions will be compiled into a curried function just
 as for lambda expressions
\begin_inset CommandInset ref
LatexCommand ref
reference "par:code-gen-Expressions"

\end_inset

, but both parameters types and the return type will also be converted between
 the JavaScript type and the corresponding Haskell type as needed.
 e.g The JavaScript implementation of the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
>= :: Int32 -> Int32 -> Bool
\end_layout

\end_inset

 operator is 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
JSHC.Internal.int32ge
\end_layout

\end_inset

, where no parameter is converted as the representation is the same in JavaScrip
t, but the result will be converted from a JavaScript boolean value to the
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
True
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
False
\end_layout

\end_inset

 data constructor of 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Prelude.Bool
\end_layout

\end_inset

.
 If the internal function takes no parameters (such as the implementation
 of undefined, which just throws a JavaScript exception) it is just an expressio
n to be evaluated.
\end_layout

\begin_layout Paragraph
Laziness
\begin_inset CommandInset label
LatexCommand label
name "par:Laziness"

\end_inset


\end_layout

\begin_layout Standard
To achieve lazy evaluation, the evaluation of some compiled expressions
 must be delayed.
\end_layout

\begin_layout Standard
Affected expressions are case expressions, function application, and compiled
 internal functions with 0 parameters, while unaffected expressions are
 integer constants, functions (lambda expressions and compiled internal
 function, like constructor applications, s with >0 parameters), and tuples.
\end_layout

\begin_layout Standard
The laziness is achieved by wrapping a compiled expression 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 in a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 and a function as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Internal-libraries"

\end_inset

.
 
\begin_inset Flex CharStyle:Emph
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 will now only be evaluated when the thunk is evaluated.
\end_layout

\begin_layout Standard
To prevent evaluation of function arguments, all function arguments are
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

s.
 Since the result of a function may be the argument to another function,
 but not used within it, results of functions are also thunks.
\end_layout

\begin_layout Standard
Whenever an expression is compiled, the result is a pair containing the
 string of the compiled Haskell expression and a boolean with the strictness
 of the expression.
\end_layout

\begin_layout Standard
Whenever a sub-expression is lazy and need to be strict, the sub-expression
 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 is evaluated.
 If a sub-expression was strict and need to be lazy, the sub-expression
 is wrapped in a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

 without function call, as the function is not necessary.
\end_layout

\begin_layout Standard
Since a name in a top-level binding might be accessed before it's expression
 is compiled (e.g recursive definitions), all expressions in top-level bindings
 are wrapped in a thunk and a function to prevent reading it until after
 the code generation is complete.
\end_layout

\begin_layout Subsection
Standard libraries
\end_layout

\begin_layout Standard
The standard Haskell libraries used for JSHC are a subset of the libraries
 described in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

.
 The contents of the JSHC Prelude are detailed in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "Flo:prelude contains"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="2">
<features>
<column alignment="center" valignment="top" width="3.6in">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
Name
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
Description
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Int32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bit integer datatype 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean datatype
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Maybe a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nullary datatype
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Either a b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&&, ||, not, otherwise
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean functions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undefined
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Undefined function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+, -, *, /
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arithmetic operators
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<, >, <=, >=, /=, ==
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arithmetic comparison operators
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identity function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
const
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constant function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function composition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
flip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument switch
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
seq
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Strict evaluation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$, $!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function application operators
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
map, ++, filter, concat, concatMap, head, tail, take
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List functions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
foldr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Right fold
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Functions and datatypes included in the JSHC Prelude
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Flo:prelude contains"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Discussion
\end_layout

\begin_layout Section
Implementation details
\begin_inset CommandInset label
LatexCommand label
name "sec:Implementation-details"

\end_inset


\end_layout

\begin_layout Subsection
Export checking
\end_layout

\begin_layout Standard
The only implementation of Haskell that we have found that implements mutually
 recursive modules is Programatica 
\begin_inset CommandInset citation
LatexCommand cite
key "the-programatica-project"

\end_inset

.
 Hugs
\begin_inset CommandInset citation
LatexCommand cite
key "hugs-user-guide"

\end_inset

 and GHC
\begin_inset CommandInset citation
LatexCommand cite
key "ghc-user-guide"

\end_inset

 do not implement mutually recursive modules as specified in the Haskell
 report.
 We were unsure of how to implement the computation of the exported names,
 as mutually recursive modules means that to compute the exports of one
 module in the cycle, it appears that one must also compute the exports
 of all the others.
 The only idea we had that seemed to actually work was a fix point iteration
 to find exported names until no more names can be found.
 One concern was efficiency, and hope of finding a simpler and more efficient
 way of computing the exported names.
 It appears to us that most people try to avoid module cycles, so we had
 some trouble finding resources about implementing it, but eventually found
\begin_inset CommandInset citation
LatexCommand cite
key "formal-haskell-module-system"

\end_inset

, which formally describes the Haskell module system using a fix point computati
on on, but we have not had enough time to implement something like it.
\end_layout

\begin_layout Subsection
Dependency checking
\end_layout

\begin_layout Standard
Dependency checking was not expected to be as big a part of the implementation
 as it turned out to be.
 It is something which one does not see as a Haskell user, and is not needed
 in many other languages that we have experience with, such as C or Java,
 as they do not have cyclic dependencies between language constructs.
 It is also only scarcely mentioned in the specification (
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 chapters 4.5 and 4.6), which somewhat hides the fact that it is a central
 concept in the workings of a Haskell compiler.
\end_layout

\begin_layout Section
Comparison with other implementations
\end_layout

\begin_layout Standard
We have chosen to only compare with other Haskell interpreters/compilers
 written in JavaScript, and we only know of one.
\end_layout

\begin_layout Subsection
Other possible solutions to client-side Haskell
\end_layout

\begin_layout Standard
If making a plug-in, one still required writing a back-end to JavaScript
 and implementing an FFI to JavaScript code.
\end_layout

\begin_layout Standard
If compiling an existing compiler like GHC to JavaScript, it would require
 an existing JavaScript back-end, and the performance of it would be important.
 There seems like there would be issues with how I/O is used within the
 compiler since it is not available in JavaScript, which would mean that
 the compiler need to be modified and can not just be compiled as is.
\end_layout

\begin_layout Subsection
HIJi (Haskell in JavaScript)
\end_layout

\begin_layout Standard
This is a Haskell interpreter written in JavaScript as part of a bachelor
 thesis project.
\end_layout

\begin_layout Standard
Their parser is not generated from a grammar description, but instead written
 in JavaScript using a parser combinator library called JSParse
\begin_inset CommandInset citation
LatexCommand cite
key "jsparse"

\end_inset

.
\end_layout

\begin_layout Standard
From the report
\begin_inset CommandInset citation
LatexCommand cite
key "hiji"

\end_inset

, it is unclear which exact subset of Haskell they have implemented, as
 it is not specified, and there is no mention of mutually recursive modules
 or dependency groups.
\end_layout

\begin_layout Standard
They have an interpreter that loads an unknown subset of the Prelude and
 allows evaluation of expressions.
 There are no error messages and no type checking is done as the type checker
 is not fully integrated with the rest of the code, but they have an implementat
ion of type classes according to their report.
\end_layout

\begin_layout Standard
Wildcards and prefix operators does not appear to work in the interpreter,
 but they do support guards and sections, which we do not.
\end_layout

\begin_layout Standard
It is supposed to be possible to load modules by placing them on the same
 server as the interpreter in the same way as in our compiler, but we were
 unable to load anything.
\end_layout

\begin_layout Standard
The interpreter has a history of written expressions, which we have yet
 to implement.
\end_layout

\begin_layout Section
Use of JSHC for web programming
\end_layout

\begin_layout Standard
As it is, JSHC works reasonably well for the subset of Haskell it supports,
 and provides both static type checking and a module system, as well as
 other high-level features (such as lazy evaluation) to the web-scripting
 domain, and it works as a proof of concept in that regard.
 It can be used as a library in a website to compile and run programs in
 the subset of Haskell that is supported.
 The Ymacs interface can also potentially be used by users new to Haskell
 who want to try the language out.
 
\end_layout

\begin_layout Standard
However, developing advanced web applications in JSHC would be problematic,
 as several key features needed to make this practical are missing (as described
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Future-work-on"

\end_inset

).
\end_layout

\begin_layout Standard
In addition, the code generated by JSHC has not been benchmarked for efficiency,
 and is likely many times slower than hand-written JavaScript (mostly because
 of the laziness).
 To be able to advertise JSHC as a feasible development platform, optimisation
 and benchmarking of the generated code needs to be done.
\end_layout

\begin_layout Section
Future work on JSHC
\begin_inset CommandInset label
LatexCommand label
name "sec:Future-work-on"

\end_inset


\end_layout

\begin_layout Subsection
Additional support of the Haskell specification
\end_layout

\begin_layout Standard
As only a small subset of Haskell is supported in JSHC, the most important
 future work is to extend its support to larger parts of the Haskell specificati
on (and eventually to supporting it in full).
\end_layout

\begin_layout Standard
There are several minor syntactic features missing, such as sections (syntactic
 sugar for partial application of binary operators), list comprehensions
 and guards.
\end_layout

\begin_layout Standard
Some major missing features are described below.
\end_layout

\begin_layout Subsubsection
FFI: Foreign Function Interface
\end_layout

\begin_layout Standard
Adding a foreign function interface to JavaScript code would simplify the
 writing of the Prelude, as primitive operations such as addition could
 be described using foreign imports instead of a name with a special prefix
 for which the type would be stored in the type checker when looking up
 the name instead of the type being written in a foreign function declaration.
\end_layout

\begin_layout Standard
More importantly, it will also allow writing Haskell libraries that wrap
 JavaScript APIs, which would greatly increase the flexibility in the developmen
t capabilities of JSHC.
\end_layout

\begin_layout Subsubsection
Type classes
\end_layout

\begin_layout Standard
Function overloading through type classes is one of the most important features
 to add.
 Overloading is an important part of Haskell, and is used by many of the
 most common functions in the standard Prelude.
 
\end_layout

\begin_layout Subsubsection
Input / output
\end_layout

\begin_layout Standard
Haskell's input/output needs to be implemented.
 Since most implementations of JavaScript do not define standard I/O channels
 such as 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
stdin
\end_layout

\end_inset

, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
stdout
\end_layout

\end_inset

 and 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
stderr
\end_layout

\end_inset

, some kind of simulation of these would be necessary.
 For example, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
stderr
\end_layout

\end_inset

 could be represented by a browser's JavaScript console.
 A file system would have to be simulated, for example as is done in JSHC
 to store the code in a buffer, by a JavaScript map from file names to contents.
  
\end_layout

\begin_layout Subsection
Possible additions to the compiler
\end_layout

\begin_layout Subsubsection
Loading files asynchronously
\end_layout

\begin_layout Standard
This is not difficult, but since only local files or files on the same domain
 may be accessed, there does not appear to be a reason to implement this.
\end_layout

\begin_layout Subsubsection
Pretty printer
\end_layout

\begin_layout Standard
To give good error messages related to expressions within functions, a pretty
 printer is required.
 Currently, data constructors are shown using unnecessary parentheses, and
 only the abstract syntax tree is available for expressions and patterns.
\end_layout

\begin_layout Subsubsection
Concurrency
\end_layout

\begin_layout Standard
To speed up compilation, the dependency group traversal could be implemented
 to run concurrently, as the implemented algorithm allows for taking out
 many groups which do not depend on each other.
 Even though extensions for concurrency exists, speed is not important in
 the compiler in it
\begin_inset Quotes ers
\end_inset

s current state.
 Lexical analysis and parsing of modules could also benefit from added concurren
cy.
\end_layout

\begin_layout Subsubsection
Code optimisation
\end_layout

\begin_layout Standard
As code generation has been designed without regard to speed, the generated
 code is most likely slower than necessary.
 For example, the naive method of solving lazy evaluation used in JSHC (wrap
 everything that might need to be lazy in a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
Thunk
\end_layout

\end_inset

, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Laziness"

\end_inset

) is unnecessarily inefficient.
 One can reduce the amount of lazy evaluation used in a program by implementing
 
\begin_inset Flex CharStyle:Strong
status collapsed

\begin_layout Plain Layout
strictness analysis
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "strictness-analysis"

\end_inset

.
\end_layout

\begin_layout Section
Issues
\end_layout

\begin_layout Standard
During the course of the project, we encountered some issues that significantly
 affected our workflow and deserve mention.
 
\end_layout

\begin_layout Subsection
Project size
\begin_inset CommandInset label
LatexCommand label
name "sub:Project-size"

\end_inset


\end_layout

\begin_layout Standard
As mentioned in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Delimitations"

\end_inset

, the intention of this project was initially to implement the full Haskell
 2010 specification.
 This was, however, not possible within the scope of a bachelor's thesis.
 Instead, a small subset of Haskell was implemented (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Supported-language-features"

\end_inset

).
 
\end_layout

\begin_layout Standard
There are several reasons for this underestimation of project size.
 
\end_layout

\begin_layout Standard
Our experience in writing compilers comes mainly from courses we have attended,
 where we have implemented compilers for simple imperative and functional
 languages.
 As we managed these courses with relative ease, implementing a full scale
 programming language like Haskell seemed feasible.
 
\end_layout

\begin_layout Standard
As the Haskell specification is often brief in its description of complex
 language features and implementation details, such as polymorphic type
 checking or overloading through type classes, as well as the features discussed
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementation-details"

\end_inset

, the challenge of implementing seemed lesser than it actually was.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition, none of the group members had used JavaScript before the start
 of this project.
 The problems caused by JavaScript's weak dynamic typing and lack of module
 system
\begin_inset CommandInset citation
LatexCommand cite
key "Mikkonen07usingjavascript"

\end_inset

 were surprisingly difficult to overcome as the project grew.
 
\end_layout

\begin_layout Subsection
The Haskell grammar
\end_layout

\begin_layout Standard
Certain features of the Haskell grammar occurred to us as peculiar and/or
 problematic when implementing the language.
\end_layout

\begin_layout Standard
The grammar in the Haskell report is at least an LR(2) grammar as it requires
 a lookahead of 2 when reading top declarations, and it has conflicts as
 an LALR grammar.
 This means that it must be rewritten for use in a LALR(1) parser generator
 such as Jison or Bison.
 This is problematic, as rewriting the grammar can be a source of errors
 that can be hard to detect.
 The grammar also contains at least one ambiguity.
 Both the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecl
\end_layout

\end_inset

 and the 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gendecl
\end_layout

\end_inset

 have empty productions, and both can be present at the top level.
 Although this ambiguity only applies to programs with empty declarations,
 and should not affect implementations, allowing for ambiguities in the
 formal specification of a language strikes us as bad practice, as it potentiall
y makes the grammar less clear and also harder to implement a parser for.
\end_layout

\begin_layout Standard
Another issue we had was that the specification defines some declarations
 as legal where the semantics are unclear or nonsensical.
 For example, 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
2 = 3
\end_layout

\end_inset

 is a valid top level declaration in Haskell, which, we assume, defines
 a pattern match which can never succeed as it is never reached to begin
 with.
 
\end_layout

\begin_layout Subsection
Interpreter: accessing URLs
\end_layout

\begin_layout Standard
The idea was that the interpreter should support adding paths to Haskell
 files residing on any url or file path.
 Unfortunately, for safety reasons, most common browsers prevent getting
 files from domains other than the one that the script is executed on.
 If using Google Chrome/Chromium, the security policy even prevents accessing
 local files using the file:// protocol when running a script from a local
 directory i.e.
 not through a web server.
 The Ymacs interface must be placed on a web server to work for browsers
 with such a restriction.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "jshc"
options "bibtotoc,plain"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Syntax reference
\end_layout

\begin_layout Standard
Detailed in this appendix is a reference to the subset of the Haskell syntax
 supported by JSHC, as well as the intermediate representation used by the
 code generation.
 
\end_layout

\begin_layout Section
Context-free syntax
\begin_inset CommandInset label
LatexCommand label
name "sec:Context-free-syntax"

\end_inset


\end_layout

\begin_layout Standard
The same notational convention used in 
\begin_inset CommandInset citation
LatexCommand cite
key "haskell-report"

\end_inset

 is used here, i.e:
\end_layout

\begin_layout Standard
[pattern] : optional
\end_layout

\begin_layout Standard
{pattern} : zero or more repetitions
\end_layout

\begin_layout Standard
(pattern) : grouping
\end_layout

\begin_layout Standard
pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 | pat
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
nonterm -> alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 | alt
\begin_inset Formula $_{\text{2}}$
\end_inset

 | … | alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 : production
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module → module modid [exports] where body 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| body
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body → { impdecls ; topdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { impdecls }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| { topdecls }
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecls → impdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; impdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exports → ( export
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , export
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
export → qvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| qtycon [(..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

 )] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| module modid
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impdecl → import modid [impspec]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (empty declaration)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
impspec → ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| hiding ( import
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , import
\begin_inset Formula $_{\text{n}}$
\end_inset

 [ , ] ) 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
import → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tycon [ (..) | ( cname
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , cname
\begin_inset Formula $_{\text{n}}$
\end_inset

)] 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
cname → var | con
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls → topdecl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; topdecl
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 0)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl → data simpletype [= constrs]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| decl
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decls → { decl
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; decl
\begin_inset Formula $_{\text{n}}$
\end_inset

 } 
\end_layout

\end_inset

(n ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl → gendecl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| (funlhs | pat) rhs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gendecl → vars :: type 
\end_layout

\end_inset

(type signature)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fixity [integer] ops 
\end_layout

\end_inset

(fixity declaration)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| 
\end_layout

\end_inset

(empty declaration)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
ops → op
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , op
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
vars → var
\begin_inset Formula $_{\text{1}}$
\end_inset

 , …, var
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fixity → infixl | infixr | infix
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
type → btype [-> type] 
\end_layout

\end_inset

(function type)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
btype → [btype] atype 
\end_layout

\end_inset

(type application)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
atype → gtycon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| tyvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , type
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple type, k ≥ 2)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ type ] 
\end_layout

\end_inset

(list type)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( type ) 
\end_layout

\end_inset

(parenthesized constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gtycon → qtycon
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
simpletype → tycon tyvar
\begin_inset Formula $_{\text{1}}$
\end_inset

 … tyvar
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(k ≥ 0)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constrs → constr
\begin_inset Formula $_{\text{1}}$
\end_inset

 | … | constr
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constr → con [!] atype
\begin_inset Formula $_{\text{1}}$
\end_inset

 … [!] atype
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(arity con = k, k ≥ 0)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
funlhs → var apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| pat varop pat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( funlhs ) apat { apat }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
rhs → = exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp → infixexp :: type 
\end_layout

\end_inset

(expression type signature)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| infixexp 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
infixexp → lexp qop infixexp 
\end_layout

\end_inset

(infix operator application)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| - infixexp 
\end_layout

\end_inset

(prefix negation)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| lexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lexp → 
\backslash
 apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{n}}$
\end_inset

 -> exp 
\end_layout

\end_inset

(lambda abstraction, n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| let decls in exp 
\end_layout

\end_inset

(let expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| if exp [;] then exp [;] else exp 
\end_layout

\end_inset

(conditional)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| case exp of { alts } 
\end_layout

\end_inset

(case expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| fexp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
fexp → [fexp] aexp 
\end_layout

\end_inset

(function application)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nopagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
aexp → qvar 
\end_layout

\end_inset

(variable)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon 
\end_layout

\end_inset

(generalized constructor)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp ) 
\end_layout

\end_inset

(parenthesized expression)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple, k ≥ 2)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| [ exp
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , exp
\begin_inset Formula $_{\text{k}}$
\end_inset

 ] 
\end_layout

\end_inset

(list, k ≥ 1)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts → alt
\begin_inset Formula $_{\text{1}}$
\end_inset

 ; … ; alt
\begin_inset Formula $_{\text{n}}$
\end_inset

 
\end_layout

\end_inset

(n ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt → pat -> exp [where decls]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat → lpat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
lpat → apat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon apat
\begin_inset Formula $_{\text{1}}$
\end_inset

 … apat
\begin_inset Formula $_{\text{k}}$
\end_inset

 
\end_layout

\end_inset

(arity gcon = k, k ≥ 1)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
apat → var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| gcon 
\end_layout

\end_inset

(arity gcon = 0)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| _ 
\end_layout

\end_inset

(wildcard)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat ) 
\end_layout

\end_inset

(parenthesized pattern)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
| ( pat
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , pat
\begin_inset Formula $_{\text{k}}$
\end_inset

 ) 
\end_layout

\end_inset

(tuple pattern, k ≥ 2)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gcon → [] | qcon
\end_layout

\end_inset

 (generalized constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
var → varid | ( varsym ) 
\end_layout

\end_inset

(variable)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvar → qvarid | ( qvarsym ) 
\end_layout

\end_inset

(qualified variable)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
con → conid | ( consym ) 
\end_layout

\end_inset

(constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qcon → qconid | ( gconsym ) 
\end_layout

\end_inset

(qualified constructor)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varop → varsym | ` varid ` 
\end_layout

\end_inset

(variable operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qvarop → qvarsym | ` qvarid ` 
\end_layout

\end_inset

(qualified variable operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
conop → consym | ` conid ` 
\end_layout

\end_inset

(constructor operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qconop → gconsym | ` qconid ` 
\end_layout

\end_inset

(qualified constructor operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
op → varop | conop 
\end_layout

\end_inset

(operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
qop → qvarop | qconop 
\end_layout

\end_inset

(qualified operator)
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
gconsym → : | qconsym 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Intermediate representation
\begin_inset CommandInset label
LatexCommand label
name "sec:B.2Intermediate-representation"

\end_inset


\end_layout

\begin_layout Standard
For detailing the intermediate representation, these notational conventions
 are used:
\end_layout

\begin_layout Standard
node → { item
\begin_inset Formula $_{\text{1}}$
\end_inset

 , … , item
\begin_inset Formula $_{\text{n}}$
\end_inset

}
\end_layout

\begin_layout Standard
item → name: value | [name: value]
\end_layout

\begin_layout Standard
rule
\begin_inset Formula $_{\text{1}}$
\end_inset

 | rule
\begin_inset Formula $_{\text{2}}$
\end_inset

 : choice
\end_layout

\begin_layout Standard
name : the name of a n item inside a node
\end_layout

\begin_layout Standard
value : the value of an item inside a node, values can be both terminals
 and nonterminals
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
module -> {name: "module",modid: <modname>, body: <body>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
body -> {name: "body", topdecls: <topdecls>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecls -> <topdecl>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <topdecl>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
topdecl -> {name: "topdecl-decl", decl: <decl>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "topdecl-data", typ: <simpletype>, constrs: <constrs>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
decl -> {name: "decl-fun", ident: <varname>, rhs: exp}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
simpletype -> {name: "simpletype", tycon: <dacon>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constrs -> <constr>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <constr>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
constr -> {name: "constr", dacon: <dacon>, types: <types>
\begin_inset Foot
status open

\begin_layout Plain Layout
Types is an array containing the arguments to a data constructor.
 At code generation, the arguments themselves are irrelevant, only the length
 of the array matters.
\end_layout

\end_inset

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exps -> <exp>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <exp>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
exp -> {name: "lambda", args: <args>, rhs: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "case", exp: <exp>, alts: <alts>}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "application", exps: <exps>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple", members: <exps>}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
At this stage, it is legal for a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
tuple-pat
\end_layout

\end_inset

 to have 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
members.length == 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "negate", exp: <exp>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alts -> <alt>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <alt>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
alt -> {name: "alt", pat <pat> exp: <exp>}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pats -> <pat>
\begin_inset Formula $_{\text{1}}$
\end_inset

 ...
 <pat>
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
pat -> {name: "conpat", con: dacon, pats: <pats>}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "tuple-pat", members: <pats>} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{2}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| {name: "wildcard"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| varname
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| dacon
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

| literal
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
modname -> {name: "modname", id: dacon}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon -> {name: "dacon", id: <STRING>} 
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
loc
\end_layout

\end_inset

 is used to determine whether a 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
dacon
\end_layout

\end_inset

 or 
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname
\end_layout

\end_inset

 is qualified, and what that qualification is.
 At this stage, anything that is not qualified is a local variable.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
varname -> {name: "varname", id: <STRING>, [loc: <STRING>]} 
\end_layout

\end_inset


\begin_inset Formula $^{\text{3}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
literal -> {name: "integer-lit", val: <NUMBER>} 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
STRING -> a JavaScript String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex CharStyle:Code
status collapsed

\begin_layout Plain Layout
NUMBER -> a JavaScript Number
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newline
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Declaration of contributions
\end_layout

\begin_layout Standard
Both group members have been equally active in the project, from planning,
 through execution to final stages.
 
\end_layout

\begin_layout Standard
Regarding implementation, Peter Holm has had the main responsibility for
 lexical analysis and code generation, while Staffan Björnesjö has had main
 responsibility over large part of the semantic analysis (name check, type
 check), dependency group analysis, loading of modules, the module system
 and user interface.
 All other parts have been developed collaboratively.
\end_layout

\begin_layout Standard
Regarding report, participants have been responsible for documenting their
 areas of responsibility in the implementation.
 All other parts have been documented collaboratively.
\end_layout

\end_body
\end_document
